<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>c++函数 | Hexo</title>
  <meta name="description" content="C++函数一个典型的函数定义包含以下几个部分：返回类型、函数名、形参及函数体 我们通过调用调用运算符()来执行函数,圆括号内用逗号隔开的是实参列表，用以初始化形参。调用表达式的类型就是函数的返回类型。 12345678910111213141516#include&lt;iostream&gt;&#x2F;&#x2F;函数的编写：5的阶乘int fact(int val)&#x2F;&#x2F;被调函数&amp;#123;    int ret">
<meta property="og:type" content="article">
<meta property="og:title" content="c++函数">
<meta property="og:url" content="https://dnanye.gitee.io/2022/10/02/c-%E5%87%BD%E6%95%B0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="C++函数一个典型的函数定义包含以下几个部分：返回类型、函数名、形参及函数体 我们通过调用调用运算符()来执行函数,圆括号内用逗号隔开的是实参列表，用以初始化形参。调用表达式的类型就是函数的返回类型。 12345678910111213141516#include&lt;iostream&gt;&#x2F;&#x2F;函数的编写：5的阶乘int fact(int val)&#x2F;&#x2F;被调函数&amp;#123;    int ret">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-10-02T10:57:41.000Z">
<meta property="article:modified_time" content="2022-10-02T10:59:44.813Z">
<meta property="article:author" content="nanye">
<meta property="article:tag" content="C++ 函数">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="https://dnanye.gitee.io/2022/10/02/c-%E5%87%BD%E6%95%B0/index.html">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 6.2.0"></head>


<body class="main-center" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/dnaye" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">无佢</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md"></h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> SuZhou, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav ">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-tags">
          <a href="/tags">
            
            <i class="icon icon-tags"></i>
            
            <span class="menu-title">标签</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/dnanye" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://gitee.com/dnanye" target="_blank" title="Gitee" data-toggle=tooltip data-placement=top><i class="icon icon-gitee"></i></a></li>
        
        <li><a href="https://m.weibo.cn/profile/6013892152" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享经验!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">分类</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C#</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C++</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/NET-FrameWork/" rel="tag">.NET FrameWork</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C#</a><span class="tag-list-count">4</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a><span class="tag-list-count">3</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-%E5%87%BD%E6%95%B0/" rel="tag">C++ 函数</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/JAVA/" rel="tag">JAVA</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" rel="tag">字符串</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%AE%B9%E5%99%A8/" rel="tag">容器</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" rel="tag">类型转换</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/" rel="tag">表达式</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%AD%E5%8F%A5/" rel="tag">语句</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a><span class="tag-list-count">1</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/NET-FrameWork/" style="font-size: 13.33px;">.NET FrameWork</a> <a href="/tags/C/" style="font-size: 14px;">C#</a> <a href="/tags/C/" style="font-size: 13.67px;">C++</a> <a href="/tags/C-%E5%87%BD%E6%95%B0/" style="font-size: 13px;">C++ 函数</a> <a href="/tags/JAVA/" style="font-size: 13px;">JAVA</a> <a href="/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/" style="font-size: 13px;">字符串</a> <a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 13px;">容器</a> <a href="/tags/%E6%95%B0%E7%BB%84/" style="font-size: 13px;">数组</a> <a href="/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/" style="font-size: 13px;">类型转换</a> <a href="/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/" style="font-size: 13px;">表达式</a> <a href="/tags/%E8%AF%AD%E5%8F%A5/" style="font-size: 13px;">语句</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 13px;">面向对象</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/10/">十月 2022</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a><span class="archive-list-count">6</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/C/">C++</a>
              </p>
              <p class="item-title">
                <a href="/2022/10/02/c-%E5%87%BD%E6%95%B0/" class="title">c++函数</a>
              </p>
              <p class="item-date">
                <time datetime="2022-10-02T10:57:41.000Z" itemprop="datePublished">2022-10-02</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/C/">C++</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/28/c-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/" class="title">c++的字符串、向量和数组</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-28T03:37:45.000Z" itemprop="datePublished">2022-09-28</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/C/">C++</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/12/c-%E5%9F%BA%E7%A1%80/c-%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/" class="title">c++语句与表达式</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-12T11:17:56.000Z" itemprop="datePublished">2022-09-12</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/C/">C#</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/10/c-class/" class="title">C#当中的类和对象</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-10T09:43:36.000Z" itemprop="datePublished">2022-09-10</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/C/">C#</a>
              </p>
              <p class="item-title">
                <a href="/2022/09/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="title">面向对象</a>
              </p>
              <p class="item-date">
                <time datetime="2022-09-10T04:46:05.000Z" itemprop="datePublished">2022-09-10</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-c-函数" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      c++函数
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2022/10/02/c-%E5%87%BD%E6%95%B0/" class="article-date">
	  <time datetime="2022-10-02T10:57:41.000Z" itemprop="datePublished">2022-10-02</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/C/">C++</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/C-%E5%87%BD%E6%95%B0/" rel="tag">C++ 函数</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2022/10/02/c-%E5%87%BD%E6%95%B0/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h1><p>一个典型的函数定义包含以下几个部分：返回类型、函数名、形参及函数体</p>
<p>我们通过调用调用运算符()来执行函数,圆括号内用逗号隔开的是实参列表，用以初始化形参。调用表达式的类型就是函数的返回类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//函数的编写：5的阶乘</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span><span class="comment">//被调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(val &gt; <span class="number">1</span>)</span><br><span class="line">		ret *=val--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">fact</span>(<span class="number">5</span>);<span class="comment">//主调函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5! is &quot;</span>&lt;&lt; j &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数的调用完成两项工作：实参初始化对应形参，二是将控制权转移给被调函数，此时主调函数的执行被暂时中断，被调函数开始执行。形参与实参需一一对应。</p>
<p><strong>局部对象</strong></p>
<p>在C++当中，名字有作用域，对象有生命周期</p>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见</li>
<li>对象的生命周期是程序执行过程中该对象存在的一段时间</li>
</ul>
<p>形参和函数体内部定义的变量称为局部变量，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域同名的其它所有声明中。</p>
<p>在所有函数体外的对象存在于程序的整个执行过程，此类对象在程序启动时被创建，直到程序结束才被销毁。</p>
<p><strong>自动对象</strong></p>
<p>只存在于块执行期间的对象称为自动对象，当块的执行结束后，块中创建的自动对象的值便成为未定义的了。</p>
<p>形参是一种自动对象，函数开始时为形参申请存储空间，一旦函数中止，形参被销毁。</p>
<p>局部变量对应的自动对象初始化时，如果变量定义本身含有初始值，用该初始值进行初始化；否则，执行默认初始化，这意味内置内置类型的未初始化局部变量将产生未定义的值</p>
<p><strong>局部静态对象</strong></p>
<p>局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并直到程序终止才被销毁，在此期间即使所在函数结束也不会有任何影响。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count_calls</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">static</span> <span class="type">size_t</span> ctr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i !=<span class="number">10</span>; ++i)</span><br><span class="line">		cout &lt;&lt; <span class="built_in">count_calls</span>() &lt;&lt;endl;	<span class="comment">//输出1-10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>函数声明</strong></p>
<p>函数的名字需要在使用前进行声明，函数只能定义一次，但是可以声明多次。</p>
<p>函数的声明（函数原型）和函数的定义相似，唯一的区别是无需函数体，用一个分号替代。</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>若形参是引用类型，它将绑定到对应的实参，否则，将实参的值拷贝后赋给形参。</p>
<p>若形参是引用类型，可以说对应实参被引用传递或者函数被传引用调用。引用形参是对应实参的别名。</p>
<p>若形参是值类型，形参和实参是相互独立的对象，这样的实参被值传递或者函数被传值调用。</p>
<p><strong>传值参数</strong></p>
<p>当初始化一个非引用类型的变量时，初始值拷贝给变量，对变量的改动不会影响初始值。以下代码与我们说的类似：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = n;</span><br><span class="line">i = <span class="number">42</span>;			<span class="comment">//不会影响n的值</span></span><br></pre></td></tr></table></figure>



<p><strong>指针形参</strong></p>
<p>指针的行为和其它非引用类型一样。当执行指针拷贝存操作时，拷贝的是指针的值。</p>
<p>拷贝后，两个指针是不同的指针，我们都可以通过这俩个指针修改它所指对象的值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码建议用引用代替，此处仅为演示效果</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">	<span class="built_in">reset</span>(&amp;i);			<span class="comment">//改变i的值而非i的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *ip = <span class="number">0</span>;			<span class="comment">//改变了ip所指对象的值</span></span><br><span class="line">    ip = <span class="number">0</span>;				<span class="comment">//实参未被改变，只改变了ip的局部拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>传引用参数</strong></p>
<p>通过使用形参，允许函数改变一个或多个实参的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">	<span class="built_in">reset</span>(i);			<span class="comment">//改变i的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> &amp;ip)</span>		<span class="comment">//ip是i的另外一个名字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ip = <span class="number">0</span>;			<span class="comment">//改变了ip所指对象的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用引用避免拷贝</strong></p>
<p>拷贝大的类类型对象或容器对象低效，甚至不支持拷贝操作。故此时可采用引用形参访问该类型对象。当函数无需修改形参的值时最好使用常量引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>使用引用形参返回额外信息</strong></p>
<p>引用形参为我们提供了返回多个结果的有效途径：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回s中c第一次出现的位置的索引</span></span><br><span class="line"><span class="comment">//occuser统计c出现的总次数</span></span><br><span class="line">string:: <span class="function">size_type <span class="title">find_char</span><span class="params">(<span class="type">const</span> string &amp;s,<span class="type">char</span> c, string::size_type &amp;occurs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = s.<span class="built_in">size</span>();</span><br><span class="line">    occurs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">decltype</span>(ret) i = <span class="number">0</span>; i !=s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] ==c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ret ==s.<span class="built_in">size</span>())</span><br><span class="line">                ret = i;</span><br><span class="line">            ++occcurs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>const形参和实参</strong></p>
<p>当形参是const时，需要注意关于顶层const的讨论，顶层const作用于对象本身。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;		<span class="comment">//ci不可改变</span></span><br><span class="line"><span class="type">int</span> i = ci;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;i;	<span class="comment">//不能对p赋值</span></span><br><span class="line">*p = <span class="number">0</span>;	<span class="comment">//正确</span></span><br></pre></td></tr></table></figure>



<p><em><strong>当实参初始化形参时会忽略顶层const，即形参的顶层const被忽略</strong></em>，当形参有顶层const时，传递给它常量对象或者非常量对象都可以；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span></span>&#123;<span class="comment">/**fcn能够读取i，但是不能向i写值**/</span>&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="comment">/**错误，重复定义fcn(int)**/</span>&#125;</span><br></pre></td></tr></table></figure>



<p><strong>指针或引用与const</strong></p>
<p>形参的初始化和变量的初始化方式一样，回顾之前的知识有助于理解本节知识。</p>
<p><em><strong>可以使用一个非常量初始化一个底层const对象</strong></em></p>
<p><em><strong>但是一个不能用const常量初始化一个非常量对象</strong></em></p>
<p>同时，普通的引用必须引用同类型的对象</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;					<span class="comment">//非常量对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *cp = &amp;i;			<span class="comment">//正确，用非常量对象初始化一个底层const,cp不能改变i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = i;			<span class="comment">//正确，用常量引用绑定一个非常量对象,r不能改变i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;			<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = cp;				<span class="comment">//错误，p与cp类型不匹配</span></span><br><span class="line"><span class="type">int</span> &amp;r3 = r;				<span class="comment">//错误，类型不匹配</span></span><br><span class="line"><span class="type">int</span> &amp;r4 = <span class="number">42</span>;				<span class="comment">//错误，不能用字面值初始化一个非常量引用</span></span><br></pre></td></tr></table></figure>

<p>按照上述有以下结果：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i;</span><br><span class="line">string::size_type ctr = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">reset</span>(&amp;i);			<span class="comment">//调用形参为int *类型的reset函数</span></span><br><span class="line"><span class="built_in">reset</span>(&amp;ci);			<span class="comment">//不能使用指向const int对象的指针初始化int *</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">reset</span>(i);			<span class="comment">//调用形参为int &amp;类型的reset函数</span></span><br><span class="line"><span class="built_in">reset</span>(ci);			<span class="comment">//错误，不能把普通引用绑定到const对象</span></span><br><span class="line"><span class="built_in">reset</span>(<span class="number">42</span>);			<span class="comment">//错误，不能将普通应用绑定到字面值上</span></span><br><span class="line"><span class="built_in">reset</span>(ctr);			<span class="comment">//错误，类型不匹配，ctr是无符号类型</span></span><br></pre></td></tr></table></figure>



<p><strong>尽量使用常量引用</strong></p>
<p>把函数不会改变的形参定义为普通的引用是一种常见的错误。会给调用者一个<em><strong>错误的误导：函数可以修改它实参的值</strong></em>，<em><strong>并且会极大限制函数能够接受的实参类型</strong></em>。</p>
<p>如之前所看到的那样，我们不能把const对象、字面值或者需要转换的对象传递给普通的形参引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不良设计，第一个形参的类型应该为const string&amp;</span></span><br><span class="line"><span class="function">string::size_type <span class="title">find_char</span><span class="params">(string &amp;s,<span class="type">char</span> c,string::size_type &amp;occurs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当使用如下调用会出问题</span></span><br><span class="line"><span class="built_in">find_char</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&#x27;o&#x27;</span>,ctr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_sentence</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string::size_type ctr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//错误，s为常量引用，而find_char接受的是普通引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(s,<span class="string">&#x27;.&#x27;</span>,ctr) = s.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; ctr ==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>数组形参</strong></p>
<p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响：</p>
<ol>
<li>不允许拷贝数组,故无法以值传递的方式使用数组参数</li>
<li>数组使用时会被转换为指针，在传递数组时，实际传递的是指向数组首元素的指针</li>
</ol>
<p>尽管不能以值传递方式传递给数组，我们可以将形参写成类似数组的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个函数等价</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> [<span class="number">10</span>])</span></span>;<span class="comment">//这个维度仅是期望数组有多少元素，实际不一定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>,j[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(&amp;i);		<span class="comment">//&amp;i的类型是int *</span></span><br><span class="line"><span class="built_in">print</span>(j);		<span class="comment">//j转换为int*并指向j[0];</span></span><br></pre></td></tr></table></figure>



<p><strong>管理指针形参</strong></p>
<ul>
<li><strong>使用标记指定数组长度</strong></li>
</ul>
<p>这种方法就是要求数组本身还有一个结束标记(这种方法的典型案例就是C风格的字符串)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(cp)				<span class="comment">//cp不是空指针</span></span><br><span class="line">        <span class="keyword">while</span>(*cp)		<span class="comment">//所指字符串不是空字符</span></span><br><span class="line">            cout &lt;&lt; *cp ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>使用标准库规范</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *beg,<span class="type">const</span> <span class="type">int</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//输出beg和end(不包含end)之间的所有数据</span></span><br><span class="line">	<span class="keyword">while</span>(beg != end)</span><br><span class="line">		cout &lt;&lt; *eg ++ &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li><strong>显示传递一个表示数组大小的形参</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ia[],<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != size; i++)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>数组形参与const</strong></p>
<p>当函数不需要对数组元素进行修改时，数组形参应当是指向const的指针</p>
<p>当函数需要对数组元素进行修改时，数组形参才不是指向const的指针</p>
<p><strong>数组引用形参</strong></p>
<p>形参可以是数组的引用，此时，引用形参绑定到对应实参（即数组）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span>			<span class="comment">//括号不可省略，不然就成为了引用的数组了（理所应当这是错误的）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> elem : arr)</span><br><span class="line">		cout &lt;&lt; elem &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>维度此处限制了print函数的可用性，只能作用于大小为10的数组</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>; j[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> k[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(&amp;i);			<span class="comment">//错误，实参不是含有10个整数的数组</span></span><br><span class="line"><span class="built_in">print</span>(j);			<span class="comment">//错误，实参不是含有10个整数的数组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><strong>传递多维数组</strong></p>
<p>当我们处理多维数组时，也是传递的是数组的首元素（其是一个数组）。指针就是一个数组的指针。数组的第二维的大小都是数值类型的一部分，不能省略：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (*matrix)[<span class="number">10</span>],<span class="type">int</span> rowSize)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> ([][<span class="number">10</span>],<span class="type">int</span> rowSize);<span class="comment">//等价</span></span></span></span><br></pre></td></tr></table></figure>



<p><strong>main:处理命令行选项</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将命令行选项通过两个可选的形参传递给main()函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;...&#125;<span class="comment">//与上等价</span></span><br></pre></td></tr></table></figure>

<p>*argv[]:是一个数组，它的元素是指向C风格字符串的指针，argv的第一个元素是程序名字或一个空字符串，接下来的元素是命令行传递过来的实参。</p>
<p>argc:数组当中字符串个数。</p>
<p><strong>含有可变形参的函数</strong></p>
<p>当我们无法预先知道应当向函数传递多少个实参时，C++11提供了两种方法：</p>
<p>若所有实参类型相同，可以传递一个名为initializer_list的标准库类型</p>
<p>若实参类型不同，可以编写一种特殊的函数，即可变参数模板</p>
<p>C++还有一种特殊的形参类型（省略符），可以用它传递可变数量的实参。这种功能一般用于C函数交互的接口程序。</p>
<p><strong>initializer_list形参</strong></p>
<p>若所有实参类型相同，可以使用一个名为initializer_list的标准库类型作为形参，这种类型可以定义在同名头文件当中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initializer_list的标准库类型支持操作</span></span><br><span class="line">initializer_list&lt;T&gt; lst;				<span class="comment">//默认初始化，T类型元素空列表</span></span><br><span class="line">initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;;		<span class="comment">//lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素均为const</span></span><br><span class="line"><span class="built_in">lst2</span>(lst);								<span class="comment">//拷贝或赋值一个initializer_list对象不会拷贝列表的元素；</span></span><br><span class="line">lst2 = lst;								<span class="comment">//拷贝后，原始列表和副本共享元素</span></span><br><span class="line"></span><br><span class="line">lst.<span class="built_in">size</span>();</span><br><span class="line">lst.<span class="built_in">begin</span>();</span><br><span class="line">lst.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure>

<p>initializer_list是一种模板类型，定义initializer_list类型对象时，必须说明列表中所含元素的类型：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;string&gt; lst;</span><br><span class="line">initializer_list&lt;<span class="type">int</span>&gt; li;			<span class="comment">//initializer_list的元素类型为int</span></span><br></pre></td></tr></table></figure>



<p>initializer_list对象的元素值均为常量，无法更改initializer_list对象当中的元素值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; il)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>();beg != il.<span class="built_in">end</span>(); ++beg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>当想向initializer_list形参传递一个值的序列，必须把序列放在一对花括号当中内：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">error_msg</span>(&#123;<span class="string">&quot;FunctionX&quot;</span>,expected,actual&#125;);		<span class="comment">//expected,actual是string对象</span></span><br></pre></td></tr></table></figure>



<h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><p><strong>无返回值函数</strong>（略）</p>
<p><strong>有返回值函数</strong>（只讲解一些内容）</p>
<p>返回值的类型必须函数返回值类型相同或能够隐式转换。</p>
<p>C++编译器可以保证每条return语句的结果类型正确。</p>
<p><strong>值返回的方式</strong></p>
<p>返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。</p>
<p>如果函数返回的是引用，那么该引用仅是它所引对象的一个别名</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会拷贝string对象</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ?s1 :s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>不要返回局部对象的引用或指针</strong></p>
<p>函数完成后，它所占的存储空间也被释放掉。故函数终止意味着局部变量的引用将指向不再有效的内存区域。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//严重错误，试图返回局部对象的引用</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">manip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string ret;</span><br><span class="line">	<span class="keyword">if</span>(!ret.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Empty&quot;</span>;		<span class="comment">//&quot;Empty&quot;是一个局部临时量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>引用返回左值</strong></p>
<p>函数的返回类型决定了函数调用是否是左值，调用一个返回引用的函数得到的是左值，其它的返回类型是右值。当返回的是常量引用，我们不能对该左值进行赋值操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">getVal</span><span class="params">(string &amp;str,string::size_type ix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;a value&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">getVal</span>(s,<span class="number">0</span>) = A;		<span class="comment">//将s[0]的值改成A</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;		<span class="comment">//输出A value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>列表初始化返回值</strong></p>
<p>C++11 标准规定，函数可以返回花括号包围的值的列表。此列表也可以用来表示函数返回的临时量进行初始化。</p>
<p>若此时列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//...</span></span><br><span class="line">	<span class="keyword">if</span>(expected.<span class="built_in">empty</span>())</span><br><span class="line">		<span class="keyword">return</span> &#123;&#125;			<span class="comment">//返回一个空的vector</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(expected == actual)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;Function&quot;</span>,<span class="string">&quot;okey&quot;</span>&#125;;<span class="comment">//返回列表初始化的vector对象</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;function&quot;</span>,expected,actual&#125;;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若返回的是内置类型，则花括号包围的列表最多只有一个值，并且该值所占空间不应该大于目标类型的空间。</p>
<p>若返回的是类类型的数据，由类本身定义初始值如何使用。</p>
<p><strong>主函数main的返回值</strong></p>
<p>返回为0表示成功，返回其它表示失败。</p>
<p><strong>递归</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(val &gt; <span class="number">1</span>)</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">factorial</span>(val <span class="number">-1</span>)*val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>返回数组的指针</strong></p>
<p>因为数组不能拷贝，所以函数不能返回数组。但是函数可以返回数组的指针和引用，但是为了简化可以使用类型别名解决：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">10</span>];			<span class="comment">//arrT是一个类型别名，它表示的类型是含有10个整数的数组</span></span><br><span class="line"><span class="keyword">typedef</span> arrT = <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">arrT *<span class="title">func</span><span class="params">(<span class="type">int</span> i)</span>				<span class="comment">//func返回一个指向含有10个整数的数组的指针</span></span></span><br></pre></td></tr></table></figure>



<p><strong>声明一个返回数组指针的函数</strong></p>
<p>在声明func时不使用类型别名，必须牢记被定义的名字后面数组的维度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p1[<span class="number">10</span>];			<span class="comment">//p1是一个含有10个数组指针的数组</span></span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">10</span>];			<span class="comment">//p2是一个指针，它指向含有10个整数的数组</span></span><br></pre></td></tr></table></figure>



<p>返回数组指针的形式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Type</span> (*<span class="built_in">function</span>(parameter_list)) [dimension]</span><br><span class="line"><span class="comment">//Type表示元素的类型</span></span><br><span class="line"><span class="comment">//dimension:数组大小</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="type">int</span> i))[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//func(int i)func函数需要一个int形参</span></span><br><span class="line"><span class="comment">// (*func(int i))：可以对函数调用的结果进行解引用</span></span><br><span class="line"><span class="comment">// (*func(int i))[10]:表示解引用func的调用将得到一个大小是10的数组</span></span><br><span class="line"><span class="comment">//int (*func(int i))[10];数组的元素是int</span></span><br></pre></td></tr></table></figure>



<p><strong>使用尾置返回类型</strong></p>
<p>为简化上述func函数，可使用尾置返回类型，任何函数的定义都能使用尾置返回，主要是在形参列表后面加上一个-&gt;符号开头。为表示函数真正的返回类型跟在形参列表后，在本该出现返回类型的地方放置一个auto</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]		<span class="comment">//func接受一个int实参，返回一个指针，该指针是一个含有10个整数的数组</span></span></span><br></pre></td></tr></table></figure>



<p><strong>使用decltype</strong></p>
<p>当我们知道函数返回的是指针或者数组，就可以使用decltype关键字声明返回类型</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> even[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//返回一个指针，该指针指向含有5个整数的数组。</span></span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">arrPtr</span>(<span class="type">int</span> i) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%<span class="number">2</span>) ? &amp;odd :&amp;even;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>decltype表示它返回的是一个指针，该指针所指对象与odd一样（类型与维度）</p>
<p>decltype步负责将数组类型转换为对应指针，所以decltype的结果是一个数组，故在函数声明时需要加上一个*符号</p>
<h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>若同一个作用域内的几个函数名字相同，形参列表不同（数量或者类型），我们称为重载函数。在调用这些函数时，编译器会根据实参的类型推测我们需要的是哪个函数。（main函数不能重载）</p>
<p>若两个函数它们的形参列表相同，返回类型不同，则第二个的函数声明出现错误。</p>
<p><strong>判断两个形参的类型是否相异</strong></p>
<p>有时候两个形参看起来不同，实际上是一致的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account &amp;acct)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account &amp;)</span></span>;<span class="comment">//省略了形参名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Phone Telno;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Phone &amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Telno &amp;)</span></span>;<span class="comment">//Phone和Telno类型相同</span></span><br></pre></td></tr></table></figure>



<p><strong>重载与const形参</strong></p>
<p>一个拥有顶层const的形参无法和另外一个没有顶层const的形参区分开来。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;		</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Phone)</span></span>;		<span class="comment">//重复声明</span></span><br></pre></td></tr></table></figure>



<p>若形参的类型是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时const是底层的</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account &amp;)</span></span>;		<span class="comment">//作用于Account引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account &amp;)</span></span>;<span class="comment">//作用于常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account *)</span></span>;		<span class="comment">//作用于Account的指针</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account *)</span></span>;	<span class="comment">//作用于指向常量的指针</span></span><br></pre></td></tr></table></figure>



<p><strong>const_cast和重载</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 :s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的形参和返回值类型都是const string引用。</p>
<p>可以使用非常量string调用这个函数，返回结果研究是const string引用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当实参不是常量时，得到的结果时普通的引用</span></span><br><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1 ,string &amp;s2)</span><span class="comment">//该函数只能接受普通的string引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将实参强制转换成const引用，后调用const版本的函数，返回一个const string类型引用</span></span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="keyword">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;s1,<span class="keyword">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;s2)</span><br><span class="line">        <span class="comment">//将const string引用转换成string&amp;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><p><strong>默认实参</strong></p>
<p>函数反复调用中它们都被赋予一个相同的值，将这个反复出现的实参定义为默认实参。调用含有默认实参的函数时，可以包含默认实参也可以忽略默认实参。</p>
<p>如果一个形参有了默认值，那么它后面所有的形参必须有默认值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>;sz wid = <span class="number">80</span>,<span class="type">char</span> backgrnd = <span class="string">&#x27;&#x27;);</span></span></span></span><br></pre></td></tr></table></figure>



<p><strong>使用默认实参调用函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string window;</span><br><span class="line">window = screen();				//等价于screen(24,80,&#x27;&#x27;);</span><br><span class="line">window = screen(66);			//等价于screen(66,80,&#x27;&#x27;);</span><br><span class="line">window = screen(66,256);		//等价于screen(66,256,&#x27;&#x27;);</span><br><span class="line">window = screen(66,256,&#x27;#&#x27;);	//等价于screen(66,256,&#x27;#&#x27;);</span><br></pre></td></tr></table></figure>

<p>函数调用时实参按位置解析，默认实参负责填补调用缺少的尾部实参（靠右边位置）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window = screen(, ,&#x27;?&#x27;);	//错误，只能省略尾部实参</span><br><span class="line">window = screen(&#x27;?&#x27;);		//调用screen(&#x27;?&#x27;,80,&#x27;&#x27;);</span><br></pre></td></tr></table></figure>

<p>当设计默认实参时，尽量让不怎么使用默认值的形参出现在前面，而让经常使用默认值的形参出现在后面。</p>
<p><strong>默认实参声明</strong></p>
<p>对于函数声明来说，通常的习惯是将其放在头文件当中，并且一个函数只声明一次。</p>
<p>在给定作用域内，形参只能赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须有默认值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz,sz,<span class="type">char</span> = <span class="string">&#x27;#&#x27;</span>)</span></span>;	<span class="comment">//高度和宽度无默认值</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz,sz,<span class="type">char</span> = <span class="string">&#x27;*&#x27;</span>)</span></span>;	<span class="comment">//错误，重复声明</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = <span class="number">24</span>,sz = <span class="number">80</span>,<span class="type">char</span>)</span></span>;	<span class="comment">//添加高度和宽度的默认值</span></span><br></pre></td></tr></table></figure>



<p><strong>默认实参初始化</strong></p>
<p>局部变量不能作为默认实参，表达式的类型能够转换为形参所需的类型，该表达式就能成为默认实参。</p>
<p><strong>内联函数和constexpr函数</strong></p>
<p>调用函数一般比等价表达式慢得多，在大多机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。</p>
<p><strong>内联函数</strong></p>
<p>将函数指定为内联函数通常是将它在每个调用点上内联地展开，在函数的返回类型前面加inline关键字便能将它声明为内联函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内联说明只是向编译器发出一个请求，编译器可忽略该请求</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 :s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>constexpr函数</strong></p>
<p>该函数是指用于常量表达式的函数，定义方法与其它函数差不多，但是需要遵循以下约定：</p>
<ul>
<li>函数的<em><strong>返回类型</strong></em>和所有形参类型都得是字面值类型</li>
<li>函数体必须有且只有一条return语句</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span>	</span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foo = <span class="built_in">new_sz</span>();</span><br></pre></td></tr></table></figure>

<p>执行new_sz函数初始化constexpr类型变量foo任务时，编译把对constexpr函数的调用替换其结果值。为了能在编译过程当中展开，constexpr函数被隐式指定内联函数。</p>
<p>constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行，例如函数体内可以有空语句、类型别名、using声明。</p>
<p>允许constexpr函数的<em><strong>返回值</strong></em>并非一个常量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">new_sz</span>()*cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//scale的实参是常量表达式时，返回值也是常量表达式，反之不然</span></span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)];		<span class="comment">//正确，scale(2)是常量表达式</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">scale</span>(i)];		<span class="comment">//错误，scale(i)不是常量表达式</span></span><br></pre></td></tr></table></figure>



<p><strong>调试帮助</strong></p>
<p>程序可以包含一些用于调试的代码，但是这些代码只能用于开发。当应用程序编写完成准备发布时，要先屏蔽该调试代码。可以使用两个预处理功能assert和NDEBUG</p>
<p><strong>assert预处理宏</strong></p>
<p>所谓的预处理宏便是一个预处理变量，它的行为类似于内联函数。assert宏使用一个表达式作为它的条件:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="comment">//无需提供对assert的using声明</span></span><br><span class="line"><span class="built_in">assert</span>(expr);</span><br><span class="line"><span class="comment">//首先expr求值  </span></span><br><span class="line"><span class="comment">//表达式为假（0），assert输出信息并终止程序的执行</span></span><br><span class="line"><span class="comment">//表达式为真（1），assert什么都不做</span></span><br></pre></td></tr></table></figure>



<p><strong>NDEBUG预处理变量</strong></p>
<p>assert的行为依赖于一个名为NDEBUG的预处理变量的状态，若定义了NDEBUG，则assert什么都不做。</p>
<p>默认状态下没有定义NDEBUG，此时assert将执行运行时检查。</p>
<p>可以使用#define 语句定义NDEBUG从而关闭调试状态同时很多编译器都提供了一个命令行选项使我们可以定义预处理变量</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">CC -D NDEBUG main.c <span class="comment">#等价于在main.c文件一开始处编写#define NDEBUG</span></span></span><br></pre></td></tr></table></figure>



<h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。函数指针指向某种特定类型。</p>
<p>函数的类型是由它的返回值类型和形参类型决定与函数名无关。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数的类型是bool(const string &amp;,const string &amp;)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//想要声明一个可以指向该类型的指针，只需要用指针替换函数名即可</span></span><br><span class="line"><span class="built_in">bool</span> (*ptr)(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;);</span><br><span class="line"><span class="comment">//ptr指向一个函数，该函数的参数是由两个const string引用形参和返回值类型bool组成</span></span><br></pre></td></tr></table></figure>



<p><strong>使用函数指针</strong></p>
<p>当我们把函数当作一个值使用时，该函数自动转换为指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> (*ptr)(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;);</span><br><span class="line">ptr = lengthCompare;		<span class="comment">//pf指向名为lengthCompare的函数</span></span><br><span class="line">ptr =&amp;lengthCompare;		<span class="comment">//等价</span></span><br></pre></td></tr></table></figure>



<p>可以直接使用指向指针函数的指针调用该函数，无需提前解引用指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b1 = <span class="built_in">ptr</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">bool</span> b1 = (*ptr)(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure>



<p>在指向函数类型的指针不存在转换规则，我们可以为函数指针赋一个nullptr或值为0的整数常量表达式，表示指针没有指向任何函数。</p>
<p><strong>重载函数的指针</strong></p>
<p>使用重载函数时，上下文必须清晰界定到底应该选哪个函数，若定义了指向重载函数的指针</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (*ptr)(<span class="type">unsigned</span> <span class="type">int</span>) = ff;		<span class="comment">//ptr指向ff(unsigned)</span></span><br></pre></td></tr></table></figure>

<p>编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某个精准匹配</p>
<p><strong>函数指针形参</strong></p>
<p>与数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际却是指针类型使用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2,<span class="type">bool</span> pf(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2,<span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以将函数当中实参使用，他会自动转换成指针</span></span><br><span class="line"><span class="built_in">useBigger</span>(s1,s2,lengthCompare);</span><br></pre></td></tr></table></figure>



<p>上述代码过于繁杂，可以用decltype简化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Func和Func2是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> string &amp;;<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FunP和FuncP2是指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FunP)</span><span class="params">(<span class="type">const</span> string &amp;;<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;</span><br></pre></td></tr></table></figure>



<p><strong>返回指向函数的指针</strong></p>
<p>与数组一样，我们无法返回一个函数，但是我们可以返回一个指向函数的指针。在这些情况下<em><strong>我们必须显式把返回类型写成指针类型</strong></em>，编译器不会自动将函数返回类型当成对应的指针类型处理</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span> *, <span class="type">int</span>);		<span class="comment">//F是函数类型</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">int</span> (*) (<span class="type">int</span> *,<span class="type">int</span>);	<span class="comment">//PF是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;		<span class="comment">//正确，PF是指向函数的指针，f1返回指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;		<span class="comment">//错误，F是函数类型，f1不能返回一个函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;		<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>))(<span class="type">int</span> *,<span class="type">int</span>);<span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt;<span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span> *,<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>将auto和decltype用于函数指针类型</strong></p>
<p>如果明确我们使用的函数是哪一个，就能使用decltype简化函数指针返回类型的过程</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有两个函数，它们的返回类型都是以string::size_type,并且各有两个const string&amp;类型的形参</span></span><br><span class="line"><span class="comment">//此时武能可以写第三个函数，它接受一个string类型形参，返回一个指针，该指针指向前两个函数的一个</span></span><br><span class="line"><span class="function">string::size_type <span class="title">sumLength</span><span class="params">(<span class="type">const</span> string&amp;,<span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function">string::size_type <span class="title">largeLength</span><span class="params">(<span class="type">const</span> string&amp;,<span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(sumLength) *<span class="built_in">getFun</span>(<span class="type">const</span> string &amp;);</span><br></pre></td></tr></table></figure>



      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://dnanye.gitee.io/2022/10/02/c-%E5%87%BD%E6%95%B0/" title="c++函数" target="_blank" rel="external">https://dnanye.gitee.io/2022/10/02/c-函数/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/dnaye" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/dnaye" target="_blank"><span class="text-dark">无佢</span><small class="ml-1x"></small></a></h3>
        <div></div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="vcomments"></div>
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    
    <li class="next">
      <a href="/2022/09/28/c-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/" title="c++的字符串、向量和数组"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/dnanye" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="https://gitee.com/dnanye" target="_blank" title="Gitee" data-toggle=tooltip data-placement=top><i class="icon icon-gitee"></i></a></li>
        
        <li><a href="https://m.weibo.cn/profile/6013892152" target="_blank" title="Weibo" data-toggle=tooltip data-placement=top><i class="icon icon-weibo"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/valine"></script>
  <script type="text/javascript">
  var GUEST = ['nick', 'mail', 'link'];
  var meta = 'nick,mail,link';
  meta = meta.split(',').filter(function(item) {
    return GUEST.indexOf(item) > -1;
  });
  new Valine({
    el: '#vcomments',
    verify: false,
    notify: false,
    appId: '',
    appKey: '',
    placeholder: 'Just go go',
    avatar: 'mm',
    meta: meta,
    pageSize: '10' || 10,
    visitor: false
  });
  </script>

     







</body>
</html>