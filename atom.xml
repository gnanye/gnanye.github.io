<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://dnanye.gitee.io/atom.xml" rel="self"/>
  
  <link href="https://dnanye.gitee.io/"/>
  <updated>2022-10-02T10:59:44.813Z</updated>
  <id>https://dnanye.gitee.io/</id>
  
  <author>
    <name>nanye</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>c++函数</title>
    <link href="https://dnanye.gitee.io/2022/10/02/c-%E5%87%BD%E6%95%B0/"/>
    <id>https://dnanye.gitee.io/2022/10/02/c-%E5%87%BD%E6%95%B0/</id>
    <published>2022-10-02T10:57:41.000Z</published>
    <updated>2022-10-02T10:59:44.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-函数"><a href="#C-函数" class="headerlink" title="C++函数"></a>C++函数</h1><p>一个典型的函数定义包含以下几个部分：返回类型、函数名、形参及函数体</p><p>我们通过调用调用运算符()来执行函数,圆括号内用逗号隔开的是实参列表，用以初始化形参。调用表达式的类型就是函数的返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="comment">//函数的编写：5的阶乘</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">fact</span><span class="params">(<span class="type">int</span> val)</span><span class="comment">//被调函数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(val &gt; <span class="number">1</span>)</span><br><span class="line">ret *=val--;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数的调用</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> j = <span class="built_in">fact</span>(<span class="number">5</span>);<span class="comment">//主调函数</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;5! is &quot;</span>&lt;&lt; j &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数的调用完成两项工作：实参初始化对应形参，二是将控制权转移给被调函数，此时主调函数的执行被暂时中断，被调函数开始执行。形参与实参需一一对应。</p><p><strong>局部对象</strong></p><p>在C++当中，名字有作用域，对象有生命周期</p><ul><li>名字的作用域是程序文本的一部分，名字在其中可见</li><li>对象的生命周期是程序执行过程中该对象存在的一段时间</li></ul><p>形参和函数体内部定义的变量称为局部变量，仅在函数的作用域内可见，同时局部变量还会隐藏在外层作用域同名的其它所有声明中。</p><p>在所有函数体外的对象存在于程序的整个执行过程，此类对象在程序启动时被创建，直到程序结束才被销毁。</p><p><strong>自动对象</strong></p><p>只存在于块执行期间的对象称为自动对象，当块的执行结束后，块中创建的自动对象的值便成为未定义的了。</p><p>形参是一种自动对象，函数开始时为形参申请存储空间，一旦函数中止，形参被销毁。</p><p>局部变量对应的自动对象初始化时，如果变量定义本身含有初始值，用该初始值进行初始化；否则，执行默认初始化，这意味内置内置类型的未初始化局部变量将产生未定义的值</p><p><strong>局部静态对象</strong></p><p>局部静态对象在程序的执行路径第一次经过对象定义语句时初始化，并直到程序终止才被销毁，在此期间即使所在函数结束也不会有任何影响。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">count_calls</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">static</span> <span class="type">size_t</span> ctr = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> ++ctr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i !=<span class="number">10</span>; ++i)</span><br><span class="line">cout &lt;&lt; <span class="built_in">count_calls</span>() &lt;&lt;endl;<span class="comment">//输出1-10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>函数声明</strong></p><p>函数的名字需要在使用前进行声明，函数只能定义一次，但是可以声明多次。</p><p>函数的声明（函数原型）和函数的定义相似，唯一的区别是无需函数体，用一个分号替代。</p><h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>若形参是引用类型，它将绑定到对应的实参，否则，将实参的值拷贝后赋给形参。</p><p>若形参是引用类型，可以说对应实参被引用传递或者函数被传引用调用。引用形参是对应实参的别名。</p><p>若形参是值类型，形参和实参是相互独立的对象，这样的实参被值传递或者函数被传值调用。</p><p><strong>传值参数</strong></p><p>当初始化一个非引用类型的变量时，初始值拷贝给变量，对变量的改动不会影响初始值。以下代码与我们说的类似：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="type">int</span> i = n;</span><br><span class="line">i = <span class="number">42</span>;<span class="comment">//不会影响n的值</span></span><br></pre></td></tr></table></figure><p><strong>指针形参</strong></p><p>指针的行为和其它非引用类型一样。当执行指针拷贝存操作时，拷贝的是指针的值。</p><p>拷贝后，两个指针是不同的指针，我们都可以通过这俩个指针修改它所指对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码建议用引用代替，此处仅为演示效果</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">reset</span>(&amp;i);<span class="comment">//改变i的值而非i的地址</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> *ip)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    *ip = <span class="number">0</span>;<span class="comment">//改变了ip所指对象的值</span></span><br><span class="line">    ip = <span class="number">0</span>;<span class="comment">//实参未被改变，只改变了ip的局部拷贝</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>传引用参数</strong></p><p>通过使用形参，允许函数改变一个或多个实参的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="built_in">reset</span>(i);<span class="comment">//改变i的值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">(<span class="type">int</span> &amp;ip)</span><span class="comment">//ip是i的另外一个名字</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ip = <span class="number">0</span>;<span class="comment">//改变了ip所指对象的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用引用避免拷贝</strong></p><p>拷贝大的类类型对象或容器对象低效，甚至不支持拷贝操作。故此时可采用引用形参访问该类型对象。当函数无需修改形参的值时最好使用常量引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isShorter</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用引用形参返回额外信息</strong></p><p>引用形参为我们提供了返回多个结果的有效途径：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回s中c第一次出现的位置的索引</span></span><br><span class="line"><span class="comment">//occuser统计c出现的总次数</span></span><br><span class="line">string:: <span class="function">size_type <span class="title">find_char</span><span class="params">(<span class="type">const</span> string &amp;s,<span class="type">char</span> c, string::size_type &amp;occurs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> ret = s.<span class="built_in">size</span>();</span><br><span class="line">    occurs = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">decltype</span>(ret) i = <span class="number">0</span>; i !=s.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i] ==c)&#123;</span><br><span class="line">            <span class="keyword">if</span>(ret ==s.<span class="built_in">size</span>())</span><br><span class="line">                ret = i;</span><br><span class="line">            ++occcurs;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>const形参和实参</strong></p><p>当形参是const时，需要注意关于顶层const的讨论，顶层const作用于对象本身。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">42</span>;<span class="comment">//ci不可改变</span></span><br><span class="line"><span class="type">int</span> i = ci;</span><br><span class="line"><span class="type">int</span> * <span class="type">const</span> p = &amp;i;<span class="comment">//不能对p赋值</span></span><br><span class="line">*p = <span class="number">0</span>;<span class="comment">//正确</span></span><br></pre></td></tr></table></figure><p><em><strong>当实参初始化形参时会忽略顶层const，即形参的顶层const被忽略</strong></em>，当形参有顶层const时，传递给它常量对象或者非常量对象都可以；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn</span><span class="params">(<span class="type">const</span> <span class="type">int</span> i)</span></span>&#123;<span class="comment">/**fcn能够读取i，但是不能向i写值**/</span>&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">fcn</span><span class="params">(<span class="type">int</span> i)</span></span>&#123;<span class="comment">/**错误，重复定义fcn(int)**/</span>&#125;</span><br></pre></td></tr></table></figure><p><strong>指针或引用与const</strong></p><p>形参的初始化和变量的初始化方式一样，回顾之前的知识有助于理解本节知识。</p><p><em><strong>可以使用一个非常量初始化一个底层const对象</strong></em></p><p><em><strong>但是一个不能用const常量初始化一个非常量对象</strong></em></p><p>同时，普通的引用必须引用同类型的对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;<span class="comment">//非常量对象</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> *cp = &amp;i;<span class="comment">//正确，用非常量对象初始化一个底层const,cp不能改变i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r = i;<span class="comment">//正确，用常量引用绑定一个非常量对象,r不能改变i</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;r2 = <span class="number">42</span>;<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> *p = cp;<span class="comment">//错误，p与cp类型不匹配</span></span><br><span class="line"><span class="type">int</span> &amp;r3 = r;<span class="comment">//错误，类型不匹配</span></span><br><span class="line"><span class="type">int</span> &amp;r4 = <span class="number">42</span>;<span class="comment">//错误，不能用字面值初始化一个非常量引用</span></span><br></pre></td></tr></table></figure><p>按照上述有以下结果：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i;</span><br><span class="line">string::size_type ctr = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">reset</span>(&amp;i);<span class="comment">//调用形参为int *类型的reset函数</span></span><br><span class="line"><span class="built_in">reset</span>(&amp;ci);<span class="comment">//不能使用指向const int对象的指针初始化int *</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">reset</span>(i);<span class="comment">//调用形参为int &amp;类型的reset函数</span></span><br><span class="line"><span class="built_in">reset</span>(ci);<span class="comment">//错误，不能把普通引用绑定到const对象</span></span><br><span class="line"><span class="built_in">reset</span>(<span class="number">42</span>);<span class="comment">//错误，不能将普通应用绑定到字面值上</span></span><br><span class="line"><span class="built_in">reset</span>(ctr);<span class="comment">//错误，类型不匹配，ctr是无符号类型</span></span><br></pre></td></tr></table></figure><p><strong>尽量使用常量引用</strong></p><p>把函数不会改变的形参定义为普通的引用是一种常见的错误。会给调用者一个<em><strong>错误的误导：函数可以修改它实参的值</strong></em>，<em><strong>并且会极大限制函数能够接受的实参类型</strong></em>。</p><p>如之前所看到的那样，我们不能把const对象、字面值或者需要转换的对象传递给普通的形参引用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不良设计，第一个形参的类型应该为const string&amp;</span></span><br><span class="line"><span class="function">string::size_type <span class="title">find_char</span><span class="params">(string &amp;s,<span class="type">char</span> c,string::size_type &amp;occurs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当使用如下调用会出问题</span></span><br><span class="line"><span class="built_in">find_char</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&#x27;o&#x27;</span>,ctr);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">is_sentence</span><span class="params">(<span class="type">const</span> string &amp;s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string::size_type ctr = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//错误，s为常量引用，而find_char接受的是普通引用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">find</span>(s,<span class="string">&#x27;.&#x27;</span>,ctr) = s.<span class="built_in">size</span>() - <span class="number">1</span> &amp;&amp; ctr ==<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组形参</strong></p><p>数组的两个特殊性质对我们定义和使用作用在数组上的函数有影响：</p><ol><li>不允许拷贝数组,故无法以值传递的方式使用数组参数</li><li>数组使用时会被转换为指针，在传递数组时，实际传递的是指向数组首元素的指针</li></ol><p>尽管不能以值传递方式传递给数组，我们可以将形参写成类似数组的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三个函数等价</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span>[])</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> [<span class="number">10</span>])</span></span>;<span class="comment">//这个维度仅是期望数组有多少元素，实际不一定</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">0</span>,j[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(&amp;i);<span class="comment">//&amp;i的类型是int *</span></span><br><span class="line"><span class="built_in">print</span>(j);<span class="comment">//j转换为int*并指向j[0];</span></span><br></pre></td></tr></table></figure><p><strong>管理指针形参</strong></p><ul><li><strong>使用标记指定数组长度</strong></li></ul><p>这种方法就是要求数组本身还有一个结束标记(这种方法的典型案例就是C风格的字符串)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *cp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(cp)<span class="comment">//cp不是空指针</span></span><br><span class="line">        <span class="keyword">while</span>(*cp)<span class="comment">//所指字符串不是空字符</span></span><br><span class="line">            cout &lt;&lt; *cp ++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>使用标准库规范</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> *beg,<span class="type">const</span> <span class="type">int</span> *)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//输出beg和end(不包含end)之间的所有数据</span></span><br><span class="line"><span class="keyword">while</span>(beg != end)</span><br><span class="line">cout &lt;&lt; *eg ++ &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>显示传递一个表示数组大小的形参</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">const</span> <span class="type">int</span> ia[],<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i != size; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; ia[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>数组形参与const</strong></p><p>当函数不需要对数组元素进行修改时，数组形参应当是指向const的指针</p><p>当函数需要对数组元素进行修改时，数组形参才不是指向const的指针</p><p><strong>数组引用形参</strong></p><p>形参可以是数组的引用，此时，引用形参绑定到对应实参（即数组）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (&amp;arr)[<span class="number">10</span>])</span><span class="comment">//括号不可省略，不然就成为了引用的数组了（理所应当这是错误的）</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> elem : arr)</span><br><span class="line">cout &lt;&lt; elem &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维度此处限制了print函数的可用性，只能作用于大小为10的数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>; j[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">int</span> k[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">print</span>(&amp;i);<span class="comment">//错误，实参不是含有10个整数的数组</span></span><br><span class="line"><span class="built_in">print</span>(j);<span class="comment">//错误，实参不是含有10个整数的数组</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>传递多维数组</strong></p><p>当我们处理多维数组时，也是传递的是数组的首元素（其是一个数组）。指针就是一个数组的指针。数组的第二维的大小都是数值类型的一部分，不能省略：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//matrix指向数组的首元素，该数组的元素是由10个整数构成的数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> (*matrix)[<span class="number">10</span>],<span class="type">int</span> rowSize)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> ([][<span class="number">10</span>],<span class="type">int</span> rowSize);<span class="comment">//等价</span></span></span></span><br></pre></td></tr></table></figure><p><strong>main:处理命令行选项</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将命令行选项通过两个可选的形参传递给main()函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;...&#125;<span class="comment">//与上等价</span></span><br></pre></td></tr></table></figure><p>*argv[]:是一个数组，它的元素是指向C风格字符串的指针，argv的第一个元素是程序名字或一个空字符串，接下来的元素是命令行传递过来的实参。</p><p>argc:数组当中字符串个数。</p><p><strong>含有可变形参的函数</strong></p><p>当我们无法预先知道应当向函数传递多少个实参时，C++11提供了两种方法：</p><p>若所有实参类型相同，可以传递一个名为initializer_list的标准库类型</p><p>若实参类型不同，可以编写一种特殊的函数，即可变参数模板</p><p>C++还有一种特殊的形参类型（省略符），可以用它传递可变数量的实参。这种功能一般用于C函数交互的接口程序。</p><p><strong>initializer_list形参</strong></p><p>若所有实参类型相同，可以使用一个名为initializer_list的标准库类型作为形参，这种类型可以定义在同名头文件当中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//initializer_list的标准库类型支持操作</span></span><br><span class="line">initializer_list&lt;T&gt; lst;<span class="comment">//默认初始化，T类型元素空列表</span></span><br><span class="line">initializer_list&lt;T&gt; lst&#123;a,b,c...&#125;;<span class="comment">//lst的元素数量和初始值一样多；lst的元素是对应初始值的副本；列表中的元素均为const</span></span><br><span class="line"><span class="built_in">lst2</span>(lst);<span class="comment">//拷贝或赋值一个initializer_list对象不会拷贝列表的元素；</span></span><br><span class="line">lst2 = lst;<span class="comment">//拷贝后，原始列表和副本共享元素</span></span><br><span class="line"></span><br><span class="line">lst.<span class="built_in">size</span>();</span><br><span class="line">lst.<span class="built_in">begin</span>();</span><br><span class="line">lst.<span class="built_in">end</span>();</span><br></pre></td></tr></table></figure><p>initializer_list是一种模板类型，定义initializer_list类型对象时，必须说明列表中所含元素的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">initializer_list&lt;string&gt; lst;</span><br><span class="line">initializer_list&lt;<span class="type">int</span>&gt; li;<span class="comment">//initializer_list的元素类型为int</span></span><br></pre></td></tr></table></figure><p>initializer_list对象的元素值均为常量，无法更改initializer_list对象当中的元素值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">error_msg</span><span class="params">(initializer_list&lt;string&gt; il)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> beg = il.<span class="built_in">begin</span>();beg != il.<span class="built_in">end</span>(); ++beg)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *beg &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当想向initializer_list形参传递一个值的序列，必须把序列放在一对花括号当中内：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">error_msg</span>(&#123;<span class="string">&quot;FunctionX&quot;</span>,expected,actual&#125;);<span class="comment">//expected,actual是string对象</span></span><br></pre></td></tr></table></figure><h2 id="返回类型和return语句"><a href="#返回类型和return语句" class="headerlink" title="返回类型和return语句"></a>返回类型和return语句</h2><p><strong>无返回值函数</strong>（略）</p><p><strong>有返回值函数</strong>（只讲解一些内容）</p><p>返回值的类型必须函数返回值类型相同或能够隐式转换。</p><p>C++编译器可以保证每条return语句的结果类型正确。</p><p><strong>值返回的方式</strong></p><p>返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。</p><p>如果函数返回的是引用，那么该引用仅是它所引对象的一个别名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不会拷贝string对象</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ?s1 :s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不要返回局部对象的引用或指针</strong></p><p>函数完成后，它所占的存储空间也被释放掉。故函数终止意味着局部变量的引用将指向不再有效的内存区域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//严重错误，试图返回局部对象的引用</span></span><br><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">manip</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">string ret;</span><br><span class="line"><span class="keyword">if</span>(!ret.<span class="built_in">empty</span>())</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Empty&quot;</span>;<span class="comment">//&quot;Empty&quot;是一个局部临时量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>引用返回左值</strong></p><p>函数的返回类型决定了函数调用是否是左值，调用一个返回引用的函数得到的是左值，其它的返回类型是右值。当返回的是常量引用，我们不能对该左值进行赋值操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span> &amp;<span class="title">getVal</span><span class="params">(string &amp;str,string::size_type ix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> str[ix];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;a value&quot;</span>)</span></span>;</span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">getVal</span>(s,<span class="number">0</span>) = A;<span class="comment">//将s[0]的值改成A</span></span><br><span class="line">    cout &lt;&lt; s &lt;&lt; endl;<span class="comment">//输出A value</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>列表初始化返回值</strong></p><p>C++11 标准规定，函数可以返回花括号包围的值的列表。此列表也可以用来表示函数返回的临时量进行初始化。</p><p>若此时列表为空，临时量执行值初始化；否则，返回的值由函数的返回类型决定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span>(expected.<span class="built_in">empty</span>())</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;<span class="comment">//返回一个空的vector</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(expected == actual)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;Function&quot;</span>,<span class="string">&quot;okey&quot;</span>&#125;;<span class="comment">//返回列表初始化的vector对象</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="string">&quot;function&quot;</span>,expected,actual&#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若返回的是内置类型，则花括号包围的列表最多只有一个值，并且该值所占空间不应该大于目标类型的空间。</p><p>若返回的是类类型的数据，由类本身定义初始值如何使用。</p><p><strong>主函数main的返回值</strong></p><p>返回为0表示成功，返回其它表示失败。</p><p><strong>递归</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(val &gt; <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">factorial</span>(val <span class="number">-1</span>)*val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>返回数组的指针</strong></p><p>因为数组不能拷贝，所以函数不能返回数组。但是函数可以返回数组的指针和引用，但是为了简化可以使用类型别名解决：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> arrT[<span class="number">10</span>];<span class="comment">//arrT是一个类型别名，它表示的类型是含有10个整数的数组</span></span><br><span class="line"><span class="keyword">typedef</span> arrT = <span class="type">int</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="function">arrT *<span class="title">func</span><span class="params">(<span class="type">int</span> i)</span><span class="comment">//func返回一个指向含有10个整数的数组的指针</span></span></span><br></pre></td></tr></table></figure><p><strong>声明一个返回数组指针的函数</strong></p><p>在声明func时不使用类型别名，必须牢记被定义的名字后面数组的维度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *p1[<span class="number">10</span>];<span class="comment">//p1是一个含有10个数组指针的数组</span></span><br><span class="line"><span class="built_in">int</span> (*p2)[<span class="number">10</span>];<span class="comment">//p2是一个指针，它指向含有10个整数的数组</span></span><br></pre></td></tr></table></figure><p>返回数组指针的形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Type</span> (*<span class="built_in">function</span>(parameter_list)) [dimension]</span><br><span class="line"><span class="comment">//Type表示元素的类型</span></span><br><span class="line"><span class="comment">//dimension:数组大小</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">func</span>(<span class="type">int</span> i))[<span class="number">10</span>];</span><br><span class="line"><span class="comment">//func(int i)func函数需要一个int形参</span></span><br><span class="line"><span class="comment">// (*func(int i))：可以对函数调用的结果进行解引用</span></span><br><span class="line"><span class="comment">// (*func(int i))[10]:表示解引用func的调用将得到一个大小是10的数组</span></span><br><span class="line"><span class="comment">//int (*func(int i))[10];数组的元素是int</span></span><br></pre></td></tr></table></figure><p><strong>使用尾置返回类型</strong></p><p>为简化上述func函数，可使用尾置返回类型，任何函数的定义都能使用尾置返回，主要是在形参列表后面加上一个-&gt;符号开头。为表示函数真正的返回类型跟在形参列表后，在本该出现返回类型的地方放置一个auto</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">func</span><span class="params">(<span class="type">int</span> i)</span> -&gt; <span class="title">int</span><span class="params">(*)</span>[10]<span class="comment">//func接受一个int实参，返回一个指针，该指针是一个含有10个整数的数组</span></span></span><br></pre></td></tr></table></figure><p><strong>使用decltype</strong></p><p>当我们知道函数返回的是指针或者数组，就可以使用decltype关键字声明返回类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> odd[] = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> even[] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="comment">//返回一个指针，该指针指向含有5个整数的数组。</span></span><br><span class="line"><span class="keyword">decltype</span>(odd) *<span class="built_in">arrPtr</span>(<span class="type">int</span> i) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%<span class="number">2</span>) ? &amp;odd :&amp;even;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>decltype表示它返回的是一个指针，该指针所指对象与odd一样（类型与维度）</p><p>decltype步负责将数组类型转换为对应指针，所以decltype的结果是一个数组，故在函数声明时需要加上一个*符号</p><h2 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h2><p>若同一个作用域内的几个函数名字相同，形参列表不同（数量或者类型），我们称为重载函数。在调用这些函数时，编译器会根据实参的类型推测我们需要的是哪个函数。（main函数不能重载）</p><p>若两个函数它们的形参列表相同，返回类型不同，则第二个的函数声明出现错误。</p><p><strong>判断两个形参的类型是否相异</strong></p><p>有时候两个形参看起来不同，实际上是一致的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account &amp;acct)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account &amp;)</span></span>;<span class="comment">//省略了形参名字</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Phone Telno;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Phone &amp;)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Telno &amp;)</span></span>;<span class="comment">//Phone和Telno类型相同</span></span><br></pre></td></tr></table></figure><p><strong>重载与const形参</strong></p><p>一个拥有顶层const的形参无法和另外一个没有顶层const的形参区分开来。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Phone)</span></span>;</span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Phone)</span></span>;<span class="comment">//重复声明</span></span><br></pre></td></tr></table></figure><p>若形参的类型是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时const是底层的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于接受引用或指针的函数来说，对象是常量还是非常量对应的形参不同</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account &amp;)</span></span>;<span class="comment">//作用于Account引用</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account &amp;)</span></span>;<span class="comment">//作用于常量引用</span></span><br><span class="line"></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account *)</span></span>;<span class="comment">//作用于Account的指针</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="type">const</span> Account *)</span></span>;<span class="comment">//作用于指向常量的指针</span></span><br></pre></td></tr></table></figure><p><strong>const_cast和重载</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 :s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数的形参和返回值类型都是const string引用。</p><p>可以使用非常量string调用这个函数，返回结果研究是const string引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当实参不是常量时，得到的结果时普通的引用</span></span><br><span class="line"><span class="function">string &amp;<span class="title">shorterString</span><span class="params">(string &amp;s1 ,string &amp;s2)</span><span class="comment">//该函数只能接受普通的string引用</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//将实参强制转换成const引用，后调用const版本的函数，返回一个const string类型引用</span></span><br><span class="line">    <span class="keyword">auto</span> &amp;r = <span class="built_in">shorterString</span>(<span class="keyword">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;s1,<span class="keyword">const_cast</span>&lt;<span class="type">const</span> string&amp;&gt;s2)</span><br><span class="line">        <span class="comment">//将const string引用转换成string&amp;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">const_cast</span>&lt;string&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="特殊用途语言特性"><a href="#特殊用途语言特性" class="headerlink" title="特殊用途语言特性"></a>特殊用途语言特性</h2><p><strong>默认实参</strong></p><p>函数反复调用中它们都被赋予一个相同的值，将这个反复出现的实参定义为默认实参。调用含有默认实参的函数时，可以包含默认实参也可以忽略默认实参。</p><p>如果一个形参有了默认值，那么它后面所有的形参必须有默认值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> string::size_type sz;</span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz ht = <span class="number">24</span>;sz wid = <span class="number">80</span>,<span class="type">char</span> backgrnd = <span class="string">&#x27;&#x27;);</span></span></span></span><br></pre></td></tr></table></figure><p><strong>使用默认实参调用函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string window;</span><br><span class="line">window = screen();//等价于screen(24,80,&#x27;&#x27;);</span><br><span class="line">window = screen(66);//等价于screen(66,80,&#x27;&#x27;);</span><br><span class="line">window = screen(66,256);//等价于screen(66,256,&#x27;&#x27;);</span><br><span class="line">window = screen(66,256,&#x27;#&#x27;);//等价于screen(66,256,&#x27;#&#x27;);</span><br></pre></td></tr></table></figure><p>函数调用时实参按位置解析，默认实参负责填补调用缺少的尾部实参（靠右边位置）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window = screen(, ,&#x27;?&#x27;);//错误，只能省略尾部实参</span><br><span class="line">window = screen(&#x27;?&#x27;);//调用screen(&#x27;?&#x27;,80,&#x27;&#x27;);</span><br></pre></td></tr></table></figure><p>当设计默认实参时，尽量让不怎么使用默认值的形参出现在前面，而让经常使用默认值的形参出现在后面。</p><p><strong>默认实参声明</strong></p><p>对于函数声明来说，通常的习惯是将其放在头文件当中，并且一个函数只声明一次。</p><p>在给定作用域内，形参只能赋予一次默认实参。函数的后续声明只能为之前那些没有默认值的形参添加默认实参，而且该形参右侧的所有形参必须有默认值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz,sz,<span class="type">char</span> = <span class="string">&#x27;#&#x27;</span>)</span></span>;<span class="comment">//高度和宽度无默认值</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz,sz,<span class="type">char</span> = <span class="string">&#x27;*&#x27;</span>)</span></span>;<span class="comment">//错误，重复声明</span></span><br><span class="line"><span class="function">string <span class="title">screen</span><span class="params">(sz = <span class="number">24</span>,sz = <span class="number">80</span>,<span class="type">char</span>)</span></span>;<span class="comment">//添加高度和宽度的默认值</span></span><br></pre></td></tr></table></figure><p><strong>默认实参初始化</strong></p><p>局部变量不能作为默认实参，表达式的类型能够转换为形参所需的类型，该表达式就能成为默认实参。</p><p><strong>内联函数和constexpr函数</strong></p><p>调用函数一般比等价表达式慢得多，在大多机器上，一次函数调用其实包含着一系列工作：调用前要先保存寄存器，并在返回时恢复；可能需要拷贝实参；程序转向一个新的位置继续执行。</p><p><strong>内联函数</strong></p><p>将函数指定为内联函数通常是将它在每个调用点上内联地展开，在函数的返回类型前面加inline关键字便能将它声明为内联函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内联说明只是向编译器发出一个请求，编译器可忽略该请求</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">const</span> string &amp;<span class="title">shorterString</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt;= s2.<span class="built_in">size</span>() ? s1 :s2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>constexpr函数</strong></p><p>该函数是指用于常量表达式的函数，定义方法与其它函数差不多，但是需要遵循以下约定：</p><ul><li>函数的<em><strong>返回类型</strong></em>和所有形参类型都得是字面值类型</li><li>函数体必须有且只有一条return语句</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">new_sz</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int</span> foo = <span class="built_in">new_sz</span>();</span><br></pre></td></tr></table></figure><p>执行new_sz函数初始化constexpr类型变量foo任务时，编译把对constexpr函数的调用替换其结果值。为了能在编译过程当中展开，constexpr函数被隐式指定内联函数。</p><p>constexpr函数体内也可以包含其他语句，只要这些语句在运行时不执行任何操作就行，例如函数体内可以有空语句、类型别名、using声明。</p><p>允许constexpr函数的<em><strong>返回值</strong></em>并非一个常量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">size_t</span> <span class="title">scale</span><span class="params">(<span class="type">size_t</span> cnt)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">new_sz</span>()*cnt;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//scale的实参是常量表达式时，返回值也是常量表达式，反之不然</span></span><br><span class="line"><span class="type">int</span> arr[<span class="built_in">scale</span>(<span class="number">2</span>)];<span class="comment">//正确，scale(2)是常量表达式</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> a2[<span class="built_in">scale</span>(i)];<span class="comment">//错误，scale(i)不是常量表达式</span></span><br></pre></td></tr></table></figure><p><strong>调试帮助</strong></p><p>程序可以包含一些用于调试的代码，但是这些代码只能用于开发。当应用程序编写完成准备发布时，要先屏蔽该调试代码。可以使用两个预处理功能assert和NDEBUG</p><p><strong>assert预处理宏</strong></p><p>所谓的预处理宏便是一个预处理变量，它的行为类似于内联函数。assert宏使用一个表达式作为它的条件:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="comment">//无需提供对assert的using声明</span></span><br><span class="line"><span class="built_in">assert</span>(expr);</span><br><span class="line"><span class="comment">//首先expr求值  </span></span><br><span class="line"><span class="comment">//表达式为假（0），assert输出信息并终止程序的执行</span></span><br><span class="line"><span class="comment">//表达式为真（1），assert什么都不做</span></span><br></pre></td></tr></table></figure><p><strong>NDEBUG预处理变量</strong></p><p>assert的行为依赖于一个名为NDEBUG的预处理变量的状态，若定义了NDEBUG，则assert什么都不做。</p><p>默认状态下没有定义NDEBUG，此时assert将执行运行时检查。</p><p>可以使用#define 语句定义NDEBUG从而关闭调试状态同时很多编译器都提供了一个命令行选项使我们可以定义预处理变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">CC -D NDEBUG main.c <span class="comment">#等价于在main.c文件一开始处编写#define NDEBUG</span></span></span><br></pre></td></tr></table></figure><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针指向的是函数而非对象。函数指针指向某种特定类型。</p><p>函数的类型是由它的返回值类型和形参类型决定与函数名无关。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数的类型是bool(const string &amp;,const string &amp;)</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//想要声明一个可以指向该类型的指针，只需要用指针替换函数名即可</span></span><br><span class="line"><span class="built_in">bool</span> (*ptr)(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;);</span><br><span class="line"><span class="comment">//ptr指向一个函数，该函数的参数是由两个const string引用形参和返回值类型bool组成</span></span><br></pre></td></tr></table></figure><p><strong>使用函数指针</strong></p><p>当我们把函数当作一个值使用时，该函数自动转换为指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">bool</span> (*ptr)(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;);</span><br><span class="line">ptr = lengthCompare;<span class="comment">//pf指向名为lengthCompare的函数</span></span><br><span class="line">ptr =&amp;lengthCompare;<span class="comment">//等价</span></span><br></pre></td></tr></table></figure><p>可以直接使用指向指针函数的指针调用该函数，无需提前解引用指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> b1 = <span class="built_in">ptr</span>(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="type">bool</span> b1 = (*ptr)(<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);</span><br></pre></td></tr></table></figure><p>在指向函数类型的指针不存在转换规则，我们可以为函数指针赋一个nullptr或值为0的整数常量表达式，表示指针没有指向任何函数。</p><p><strong>重载函数的指针</strong></p><p>使用重载函数时，上下文必须清晰界定到底应该选哪个函数，若定义了指向重载函数的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">int</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ff</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span>)</span></span>;</span><br><span class="line"><span class="built_in">void</span> (*ptr)(<span class="type">unsigned</span> <span class="type">int</span>) = ff;<span class="comment">//ptr指向ff(unsigned)</span></span><br></pre></td></tr></table></figure><p>编译器通过指针类型决定选用哪个函数，指针类型必须与重载函数中的某个精准匹配</p><p><strong>函数指针形参</strong></p><p>与数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。此时，形参看起来是函数类型，实际却是指针类型使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2,<span class="type">bool</span> pf(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">useBigger</span><span class="params">(<span class="type">const</span> string &amp;s1,<span class="type">const</span> string &amp;s2,<span class="type">bool</span> (*pf)(<span class="type">const</span> string &amp;,<span class="type">const</span> string &amp;))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以将函数当中实参使用，他会自动转换成指针</span></span><br><span class="line"><span class="built_in">useBigger</span>(s1,s2,lengthCompare);</span><br></pre></td></tr></table></figure><p>上述代码过于繁杂，可以用decltype简化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Func和Func2是函数类型</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="type">bool</span> <span class="title">Func</span><span class="params">(<span class="type">const</span> string &amp;;<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> Func2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//FunP和FuncP2是指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FunP)</span><span class="params">(<span class="type">const</span> string &amp;;<span class="type">const</span> string &amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;</span><br></pre></td></tr></table></figure><p><strong>返回指向函数的指针</strong></p><p>与数组一样，我们无法返回一个函数，但是我们可以返回一个指向函数的指针。在这些情况下<em><strong>我们必须显式把返回类型写成指针类型</strong></em>，编译器不会自动将函数返回类型当成对应的指针类型处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="built_in">int</span>(<span class="type">int</span> *, <span class="type">int</span>);<span class="comment">//F是函数类型</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="built_in">int</span> (*) (<span class="type">int</span> *,<span class="type">int</span>);<span class="comment">//PF是指针类型</span></span><br><span class="line"></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//正确，PF是指向函数的指针，f1返回指向函数的指针</span></span><br><span class="line"><span class="function">F <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//错误，F是函数类型，f1不能返回一个函数</span></span><br><span class="line"><span class="function">F *<span class="title">f1</span><span class="params">(<span class="type">int</span>)</span></span>;<span class="comment">//正确</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> (*<span class="built_in">f1</span>(<span class="type">int</span>))(<span class="type">int</span> *,<span class="type">int</span>);<span class="comment">//正确</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">f1</span><span class="params">(<span class="type">int</span>)</span> -&gt;<span class="title">int</span><span class="params">(*)</span><span class="params">(<span class="type">int</span> *,<span class="type">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>将auto和decltype用于函数指针类型</strong></p><p>如果明确我们使用的函数是哪一个，就能使用decltype简化函数指针返回类型的过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有两个函数，它们的返回类型都是以string::size_type,并且各有两个const string&amp;类型的形参</span></span><br><span class="line"><span class="comment">//此时武能可以写第三个函数，它接受一个string类型形参，返回一个指针，该指针指向前两个函数的一个</span></span><br><span class="line"><span class="function">string::size_type <span class="title">sumLength</span><span class="params">(<span class="type">const</span> string&amp;,<span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"><span class="function">string::size_type <span class="title">largeLength</span><span class="params">(<span class="type">const</span> string&amp;,<span class="type">const</span> string&amp;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(sumLength) *<span class="built_in">getFun</span>(<span class="type">const</span> string &amp;);</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-函数&quot;&gt;&lt;a href=&quot;#C-函数&quot; class=&quot;headerlink&quot; title=&quot;C++函数&quot;&gt;&lt;/a&gt;C++函数&lt;/h1&gt;&lt;p&gt;一个典型的函数定义包含以下几个部分：返回类型、函数名、形参及函数体&lt;/p&gt;
&lt;p&gt;我们通过调用调用运算符()来执行函数,</summary>
      
    
    
    
    <category term="C++" scheme="https://dnanye.gitee.io/categories/C/"/>
    
    
    <category term="C++ 函数" scheme="https://dnanye.gitee.io/tags/C-%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>c++的字符串、向量和数组</title>
    <link href="https://dnanye.gitee.io/2022/09/28/c-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/"/>
    <id>https://dnanye.gitee.io/2022/09/28/c-%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</id>
    <published>2022-09-28T03:37:45.000Z</published>
    <updated>2022-09-28T03:41:57.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="命名空间的using声明"><a href="#命名空间的using声明" class="headerlink" title="命名空间的using声明"></a>命名空间的using声明</h2><p>作用域操作符**::**的含义是：编译器应该从左边名字所示的作用域当中寻找右侧的那个名字。</p><p>故我们用的std::cout的含义是：编译器编译器从std命名空间的作用域当中寻找cout这个名字。</p><p>有了using我们就无须专门的前缀也能使用using声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span>::name</span><br><span class="line">    </span><br><span class="line"><span class="comment">//例如：</span></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;<span class="comment">//每一条语句单独写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//头文件里面不应该包含using声明</span></span><br></pre></td></tr></table></figure><h2 id="标准库类型string"><a href="#标准库类型string" class="headerlink" title="标准库类型string"></a>标准库类型string</h2><p>标准库string表示可变长的字符序列，使用string类型应加入&lt;string&gt;头文件,string也在命名空间std当中。</p><p><strong>定义和初始化string对象</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string s1;<span class="comment">//默认初始化，s1是一个空字符串</span></span><br><span class="line">string s2 = s1;<span class="comment">//s2是s1的副本，拷贝初始化（用&quot;=&quot;进行初始化）</span></span><br><span class="line"></span><br><span class="line">string s3 = <span class="string">&quot;hi&quot;</span>;<span class="comment">//s3是字符串字面值的一个副本，拷贝初始化</span></span><br><span class="line"><span class="function">string <span class="title">s4</span><span class="params">(<span class="string">&quot;hi&quot;</span>)</span></span>;<span class="comment">//s4是hi的字符串的一个副本，直接初始化，用&quot;()&quot;进行初始化</span></span><br><span class="line"></span><br><span class="line"><span class="function">string <span class="title">s5</span><span class="params">(<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>)</span></span>;<span class="comment">//s4的内容为cc，直接初始化</span></span><br></pre></td></tr></table></figure><p><strong>string对象上的操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s1;<span class="comment">//初始化一个空字符串</span></span><br><span class="line">    cin &gt;&gt; s1;<span class="comment">//从标准输入流读取字符串到s1当中，以空白为分隔,返回一个cin</span></span><br><span class="line">    cout &lt;&lt; s1 &lt;&lt;endl;<span class="comment">//将s1的内容输出到标准输出流os当中，返回一个处理完的cout</span></span><br><span class="line"><span class="comment">/*****</span></span><br><span class="line"><span class="comment">当输入Hello World!!! 你好，世界</span></span><br><span class="line"><span class="comment">s1从cin当中读取Hello，无法往后读取。</span></span><br><span class="line"><span class="comment">当中还具有流里面还有&quot;World!!! 你好，世界&quot;这个字符串的数据</span></span><br><span class="line"><span class="comment">********/</span>    </span><br><span class="line">    </span><br><span class="line">    string s2;<span class="comment">//初始化一个空字符串</span></span><br><span class="line">    <span class="built_in">getline</span>(cin,s2);<span class="comment">//从cin当中读取一行，其中那个换行符被丢弃了</span></span><br><span class="line">    cout&lt;&lt; s2 &lt;&lt;endl;</span><br><span class="line"><span class="comment">/****</span></span><br><span class="line"><span class="comment">s2将剩余的数据全部读取，故</span></span><br><span class="line"><span class="comment">输出为 &quot;World!!! 你好，世界&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取未知数量的string对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string word;</span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; word)<span class="comment">//反复读取直至达到文件末尾</span></span><br><span class="line">cout &lt;&lt; word &lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>string的empty和size操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!word.<span class="built_in">empty</span>())<span class="comment">//判断string对象word里面是否为空</span></span><br><span class="line">    <span class="keyword">if</span>(word.<span class="built_in">size</span>() &gt; <span class="number">80</span>)<span class="comment">//判断word。size()的字符个数有多少</span></span><br></pre></td></tr></table></figure><p>string::size_type类型</p><p>string对象的size()方法返回的是size_type的数据类型，这个类型是string类的定义在string类当中。</p><p>size_type的具体细节我们无法知晓，但是我们可以知道size_type是一个无符号类型的值，而且能够存放任何对象的大小。</p><p>在C++11标准当中，我们可以使用auto和decltype来推断变量的类型，可用于size_type</p><p>比较string对象：</p><p>​1、如果两个string对象的长度不同，而且较短对象的每个string对象的每个字符都与较长string对象对应位置的字符相同，就说较短string对象小于较长string对象。</p><p>​2、如果两个string对象在某些位置上不一样，则string对象比较的结果其实是string对象第一对相异字符比较的结果。</p><p>为string对象赋值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">str1</span><span class="params">(<span class="number">10</span>,<span class="string">&#x27;c&#x27;</span>)</span>,str2</span>;<span class="comment">//str1d的值为cccccccccc,str2为空字符串</span></span><br><span class="line">string str3=str2;</span><br></pre></td></tr></table></figure><p>string对象相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string str1 = <span class="string">&quot;hello &quot;</span>,string str2 = <span class="string">&quot;world!&quot;</span>;</span><br><span class="line">string str3 = str1 + str2;<span class="comment">//str3=hello world!</span></span><br></pre></td></tr></table></figure><p>string对象和字面值相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line">string s2 = s1 + <span class="string">&quot;world!&quot;</span>;<span class="comment">//s2=hello world!</span></span><br><span class="line">string s3 = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world!&quot;</span>;<span class="comment">//错误，字面值之间不能相加</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>处理string对象中的字符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//相关函数</span></span><br><span class="line"><span class="built_in">isalnum</span>(c);<span class="comment">//当c是字母或者数字时为真</span></span><br><span class="line"><span class="built_in">isalpha</span>(c);<span class="comment">//当c是字母时为真 </span></span><br><span class="line"><span class="built_in">iscntrl</span>(c);     <span class="comment">//当c为控制字符时为真</span></span><br><span class="line"><span class="built_in">isdigtal</span>(c);<span class="comment">//当c为数字时为真</span></span><br><span class="line"><span class="built_in">isgrapph</span>(c);<span class="comment">//当c不是空格时为真</span></span><br><span class="line"><span class="comment">//.....</span></span><br></pre></td></tr></table></figure><p>处理字符串当中的每个字符</p><p>使用范围for可以遍历string对象的所有字符，范围for这种语句遍历给定序列中的每个元素并对序列的执行某种操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;hello world!&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> c : str)<span class="comment">//string对象表示一个字符的序列</span></span><br><span class="line">    cout &lt;&lt; c &lt;&lt; endl;<span class="comment">//每次遍历c的变量就会被初始化为下一个元素</span></span><br></pre></td></tr></table></figure><p>需要处理一部分字符</p><p>访问字符串对象的单个字符有两种方式，一种是使用下标，另一种是使用迭代器。</p><p>下标运算符（[]）接受的参数为size_type类型的值，表示访问的字符的位置；返回值为该位置上的引用。</p><p>string对象的下标从0开始，到size()-1结束。</p><h2 id="标准库类型vector"><a href="#标准库类型vector" class="headerlink" title="标准库类型vector"></a>标准库类型vector</h2><p>vector表示对象的集合（也称为容器），其中的对象的类型都相同。集合中的每个对象都有着与之对应的索引，索引可用于访问对象。</p><p>想要使用vector对象必须使用合适的头文件，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::vector;    </span><br></pre></td></tr></table></figure><p>C++既有类模板，也有函数模板。其中vector是一个类模板，其中模板本身不是类或函数，只不过是编译器生成类和函数编写的一份说明。编译器根据模板创建类和函数的过程称为实例化，当使用模板时，需要指出编译器和函数实例化为何种类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; ivaec;<span class="comment">//ivec保存int类型数据</span></span><br><span class="line">vector&lt;Sale_item&gt; Sales_vec;<span class="comment">//保存Sale_item类型数据</span></span><br></pre></td></tr></table></figure><p>vector并非类型，故vector生成的类型包含是元素的类型。</p><p>因为引用并非对象，所以vector无法容纳引用</p><p><strong>定义和初始化vector对象</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">vector &lt;T&gt; v1;<span class="comment">//v1是一个空的vector，它的潜在元素为T类型，执行的是默认初始化，不包含任何元素</span></span><br><span class="line">vector &lt;T&gt; v2 = v1;<span class="comment">//v2包含v1所有元素的副本</span></span><br><span class="line">vector &lt;T&gt; <span class="built_in">v2</span>(v1);<span class="comment">//v2包含v1所有元素的副本,与vector &lt;T&gt; v2 = v1;一致</span></span><br><span class="line"></span><br><span class="line">vector &lt;T&gt; <span class="built_in">v3</span>(n,val);<span class="comment">//v3包含n个重复的元素，每个元素的值均为val</span></span><br><span class="line">vector &lt;T&gt; <span class="built_in">v4</span>(n);<span class="comment">//v4包含n个包含了重复执行了值初始化的对象</span></span><br><span class="line"></span><br><span class="line">vector &lt;T&gt; v5&#123;a,b,c...&#125;;<span class="comment">//v5比较了初始化个数的元素，每个元素被赋予相应的初始值。</span></span><br><span class="line">vector &lt;T&gt; v5=&#123;a,b,c...&#125;;<span class="comment">//与上一条相似，这种方式叫做列表初始化</span></span><br></pre></td></tr></table></figure><p><strong>值初始化</strong></p><p>通常情况下，可以只提供vector对象容纳的元素数量而略去初始值，此时库会创建一个值初始化元素的元素初值，并将它赋给容器当中的所有元素。</p><p>若vector对象的元素是内置类型，则元素初始值为0</p><p>若vector对象的元素是某种类类型，比如string，则该元素由该类型默认初始化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//10个元素均被默认初始化为0</span></span><br><span class="line"><span class="function">vector&lt;sting&gt; <span class="title">svec</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//10个元素均被默认初始化为&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>这种初始化方式有两个特殊的限制：</p><p>1）某些类要求必须明确的提供初始值，即该类型不支持默认初始化，我们必须提供初始元素值。</p><p>2）若只提供元素的数量而没有设定初始值，只能用直接初始化。</p><p><strong>列表初始化与元素数量</strong></p><p>初始化时，若使用圆括号()时：一般说提供的值是为了构造一个vector对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(<span class="number">10</span>)</span></span>;<span class="comment">//v1有10个元素，每个元素都是0</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>;<span class="comment">//v2有10个元素，每个元素都是1</span></span><br></pre></td></tr></table></figure><p>初始化时，若使用花括号{}时：一般说列表初始化vector对象。即初始化尽可能将花括号里的值当作元素初始值的列表来处理，<em><strong>只有无法执行列表初始化时才会考虑其他初始化方式。</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v3&#123;<span class="number">10</span>&#125;;<span class="comment">//v3有1个元素，该元素的值为10</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v4&#123;<span class="number">1</span>,<span class="number">10</span>&#125;;<span class="comment">//v4有2个元素，该vector里的元素值为1，10</span></span><br></pre></td></tr></table></figure><p><em><strong>当列表初始化的值提供无法执行列表初始化时，考虑构造vector对象</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; v5&#123;<span class="string">&quot;hello&quot;</span>&#125;;<span class="comment">//列表初始化</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">v6</span><span class="params">(<span class="string">&quot;hello&quot;</span>)</span></span>;<span class="comment">//不能使用字符串字面值构造vector对象</span></span><br><span class="line"></span><br><span class="line">vector&lt;string&gt; v7&#123;<span class="number">10</span>&#125;;<span class="comment">//直接初始化，有10个元素</span></span><br><span class="line">vector&lt;string&gt; v8&#123;<span class="number">10</span>,<span class="string">&quot;hi&quot;</span>&#125;;<span class="comment">//v4有10个元素，每个元素的值为&quot;hi&quot;</span></span><br></pre></td></tr></table></figure><p><strong>向vector对象当中添加元素</strong></p><p>一般在无法确定元素的数量时，可以创建一个空的vector，而后利用vector的push_back方法向其中添加元素，push_back负责将一个值当作vector对象的尾元素压到vector对象的尾端</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string word;</span><br><span class="line">vector&lt;string&gt; text;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意，请不要使用范围for向vector对象添加对象。范围for语句当中不应改变遍历序列的大小</span></span><br><span class="line"><span class="keyword">while</span>(cin &gt;&gt; word)&#123;</span><br><span class="line">text.<span class="built_in">push_back</span>(word);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>其它vector操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v.<span class="built_in">empty</span>();</span><br><span class="line">v.<span class="built_in">size</span>();</span><br><span class="line">v.<span class="built_in">push_back</span>(c);</span><br><span class="line">v[n];<span class="comment">//返回v中第n个位置元素的引用</span></span><br><span class="line">v1=v2;<span class="comment">//用v2当中元素拷贝替换v1的元素</span></span><br><span class="line">v1=&#123;a,b,c...&#125;;</span><br></pre></td></tr></table></figure><p>vector的下标运算只能用于访问已有的元素，无法用于添加元素。</p><h2 id="迭代器介绍"><a href="#迭代器介绍" class="headerlink" title="迭代器介绍"></a>迭代器介绍</h2><p>迭代器与指针类型一样，都提供了对对象的间接访问。</p><p>就迭代器而言，其对象是容器中的元素或者string对象中的字符。</p><p>使用迭代器可以访问某个元素，迭代器也能从一个元素移动到另外一个元素。</p><p><strong>使用迭代器</strong></p><p>有迭代器的类型同时拥有迭代器返回迭代器的成员，比如这些迭代器都拥有begin和end成员。</p><p>其中begin成员返回指向第一个元素（或第一个字符）的迭代器</p><p>end成员负责返回指向容器（或string对象）“尾元素的下一个位置的迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> b = v.<span class="built_in">begin</span>();<span class="comment">//b指v的第一个元素</span></span><br><span class="line"><span class="keyword">auto</span> e = v.<span class="built_in">end</span>();<span class="comment">//e指v的最后一个元素的下一个位置，该迭代器指示的是v不存在的尾后元素，无实际意义，只是用于标记</span></span><br></pre></td></tr></table></figure><p>特殊情况下，若容器为空，begin和end返回的同一个迭代器——都是尾后迭代器。</p><p><strong>迭代器运算符</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">*item;<span class="comment">//返回迭代器item所指元素的引用</span></span><br><span class="line">item-&gt;mem;<span class="comment">//解引用item并获取该元素的名为mem的成员，等价于(*item).mem</span></span><br><span class="line">++ item;<span class="comment">//令item指示下一个元素</span></span><br><span class="line">-- item;<span class="comment">//令item指示上一个元素</span></span><br><span class="line"></span><br><span class="line">item1 == item2;</span><br><span class="line">item1 != item2;<span class="comment">//判断两个迭代器是否相等（或不等），若两个迭代器指示的是同一个元素或它们是同一个容器的尾后迭代器，则相等。</span></span><br></pre></td></tr></table></figure><p>执行解引用的迭代器必须合法并且确实指示某个元素，试图解引用一个非法迭代器或尾后迭代器都是未定义的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">s</span><span class="params">(<span class="string">&quot;some string&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">if</span>(s.<span class="built_in">begin</span>() !=s.end )</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将迭代器从一个元素移动到另外一个元素</strong></p><p>迭代器使用递增运算符来从一个元素移动到下一个元素。end返回的迭代器不是实际指示某个元素，所以不能对其进行递增或解引用操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> it = s.<span class="built_in">begin</span>();it != s.end &amp;&amp; <span class="built_in">isspace</span>(*it);++it)</span><br><span class="line">    *it = <span class="built_in">toupper</span>(*it);<span class="comment">//将it解引用的结果传入toupper函数</span></span><br></pre></td></tr></table></figure><p><strong>迭代器类型</strong></p><p>一般来说，我们无法（也无需知道）迭代器的精确类型。实际上，那些拥有迭代器的标准库类型使用iterator和const_iterator来代表迭代器的类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;<span class="comment">//it能够读写vector&lt;int&gt;的元素</span></span><br><span class="line">string::iterator it2;<span class="comment">//it2能够读写string的元素</span></span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator it3;<span class="comment">//it3只能读vector&lt;int&gt;的元素，不能写元素</span></span><br><span class="line">string::const_iterator it2;<span class="comment">//it4只能读string的字符，不能写字符</span></span><br></pre></td></tr></table></figure><p>若vector对象或string对象是一个常量，只能使用const_iterator;</p><p>若vector对象或string对象不是一个常量，能使用const_iterator和iterator;</p><p><strong>begin和end运算符</strong></p><p>begin和end运算符返回的结果是由对象是否是常量决定的，若对象是常量，返回的是const_iterator，反之，则是iterator</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="type">const</span> vector&lt;<span class="type">int</span>&gt; cv;</span><br><span class="line"><span class="keyword">auto</span> it1 = v.<span class="built_in">begin</span>();<span class="comment">//it1的类型是vector&lt;int&gt;::iterator</span></span><br><span class="line"><span class="keyword">auto</span> it2 = cv.<span class="built_in">begin</span>();<span class="comment">//it2的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure><p>为方便专门得到const_iterator类型的返回值(无论容器是否是常量），C++11 标准引入了两个新函数，分别是cbegin和cend:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> it3 = v.cbegin<span class="comment">//it3的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure><p><strong>结合解引用和成员访问操作</strong></p><p>解引用迭代器可得到迭代器所指的对象，如果迭代器指的对象类型是类类型，那么可以进一步访问它的成员。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(*it).<span class="built_in">empty</span>();</span><br><span class="line">it-&gt;<span class="built_in">empty</span>();</span><br></pre></td></tr></table></figure><p>但凡使用了迭代器的循环体，都不要向迭代器所属容器添加容器。</p><p><strong>迭代器运算</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iter + n;</span><br><span class="line">iter - n;</span><br><span class="line">iter1 +=n;</span><br><span class="line">iter1 -=n;</span><br><span class="line">iter1 - iter2;<span class="comment">//两个迭代器相减的结果是他们之间的距离,结果类型为difference_type带符号整型</span></span><br><span class="line">&gt;、&lt;、&gt;=、&lt;=</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是一种类似于vector的数据结构，但是有所不同，例如<strong>数组大小不可改变</strong>，比之vector少了一些灵活性，但是运行性能好。</p><p><strong>定义和初始化内置数组</strong></p><p>数组是一种复合类型，数组的类型声明形如a[d];</p><p>其中a是数组名（在后续会介绍其也是指向数组首元素的指针）</p><p>d是数组的维度，维度说明数组当中元素的个数，因此d必须大于0</p><p>数组的个数属于数组类型的一部分，在编译期时维度就应该是已知的，故维度必须是一个常量表达式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> cnt = <span class="number">42</span>;<span class="comment">//不是常量表达式</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">unsigned</span> sz = <span class="number">42</span>;<span class="comment">//常量表达式</span></span><br><span class="line"><span class="type">int</span> arr[<span class="number">10</span>];</span><br><span class="line"><span class="type">int</span> *parr[sz];<span class="comment">//含有42个int指针的数组</span></span><br><span class="line">string bad[cnt];<span class="comment">//错误</span></span><br><span class="line">string strs[<span class="built_in">get_size</span>()];<span class="comment">//get_size()返回的必须是constexpr,否则出错</span></span><br></pre></td></tr></table></figure><p>不允许使用auto关键字由初始化列表的列表推断类型</p><p>数组的元素应该为对象，因此不存在引用的数组</p><p><strong>显式初始化数组元素</strong></p><p>可以对数组的元素进行列表初始化，此时允许忽略数组的维度，可以交由编译器推断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">unsigned</span> sz = <span class="number">3</span>;</span><br><span class="line"><span class="type">int</span> ia1[sz] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="comment">//有三个元素的数组，分别为0，1，2</span></span><br><span class="line"><span class="type">int</span> a[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="comment">//有三个元素的数组，分别为0，1，2</span></span><br><span class="line"><span class="type">int</span> a2[<span class="number">5</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;<span class="comment">//有五个元素的数组，分别为0，1，2，0，0</span></span><br><span class="line"><span class="type">int</span> a5[<span class="number">2</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;<span class="comment">//初始值过多</span></span><br></pre></td></tr></table></figure><p><strong>字符数组的特殊性</strong></p><p>字符数组有一种额外的初始化形式，可以用字符串字面值对此类数组进行初始化。</p><p>当时用这种初始化方式时，注意字符串字面值的结尾还有一个空字符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> a1[] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>&#125;;<span class="comment">//列表初始化，无空字符</span></span><br><span class="line"><span class="type">char</span> a2[] = &#123;<span class="string">&#x27;h&#x27;</span>,<span class="string">&#x27;i&#x27;</span>,<span class="string">&#x27;\0&#x27;</span>&#125;;<span class="comment">//列表初始化，含有显示初始化</span></span><br><span class="line"><span class="type">char</span> a3[] = <span class="string">&quot;C++&quot;</span><span class="comment">//自动添加表示字符串结束的空字符串</span></span><br></pre></td></tr></table></figure><p><strong>不允许拷贝和赋值</strong></p><p>不能将数组的内容拷贝给其他数组作为初始值，也不能用数组为其它数组为其他数组赋值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a[] = &#123;0,1,2&#125;;</span><br><span class="line">int a2[] = a;//错误，不允许使用一个数组初始化另外一个数组</span><br><span class="line">a2 = a;//错误，不允许使用一个数组直接赋值给另外一个数组</span><br></pre></td></tr></table></figure><p><strong>理解复杂的数组声明</strong></p><p>因为数组本身是一个对象，所以可以定义数组的指针和数组的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptrs[<span class="number">10</span>];<span class="comment">//ptrs是含有10个整数指针的数组</span></span><br><span class="line"><span class="type">int</span> &amp;refs[<span class="number">10</span>]= <span class="comment">/*?*/</span>;<span class="comment">//错误，不存在引用的数组</span></span><br><span class="line"><span class="built_in">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;<span class="comment">//Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="built_in">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;<span class="comment">//arrRef引用一个含有10个整数的数组   </span></span><br></pre></td></tr></table></figure><p>默认情况下，类型修饰符从右到左依次绑定。</p><p>ptrs理解：</p><p>​1、我们定义了大小为10的数组</p><p>​2、它的名字叫做ptrs</p><p>​3、数组当中存放的是指向int的指针</p><p>就数组而言，由内向外阅读比较合适，故</p><p>Parray的含义：</p><p>​1、括号内部的内容*Parray意味着Parray是一个指针</p><p>​2、观察右边，Parray是一个指向大小为10的数组的指针</p><p>​3、最后观察左边，数组的元素是int类型</p><p>即Parray是一个指针，它指向一个int数组，该数组当中包含10个元素。</p><p>同理：arrayRef是一个引用，它引用的是一个数组，该数组当中包含10个元素</p><p><strong>访问数组元素</strong></p><p>数组的元素也能使用范围for语句或下标运算符进行访问，数组的索引从0开始。</p><p>在使用数组下标的时候，通常将其定义size_t类型，size_type是一种机器相关无符号类型，其被设计得足够表示内存任意对象的大小。</p><p>在cstddef头文件中定义了size_类型</p><p><strong>指针和数组</strong></p><p>使用数组是编译器一般将其转换为指针，我们可以使用取地址符得到该数组指定位置的元素的指针。</p><p>数组名会被编译器自动替换为指向数组首元素的指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string nums[] = &#123;<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>&#125;;</span><br><span class="line">string *p = &amp;nums[<span class="number">0</span>];</span><br><span class="line">string *p1 = nums;<span class="comment">//等价于string *p1 = &amp;nums[0];</span></span><br></pre></td></tr></table></figure><p>由上可知，在一些情况下数组的操作实际上是指针的操作；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//ia是一个含有10个整数的数组</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ia2</span><span class="params">(ia)</span></span>;<span class="comment">//ia2是一个整型指针，指向ia的第一个元素</span></span><br><span class="line"><span class="comment">//实际情况：</span></span><br><span class="line"><span class="comment">//auto ia2(&amp;ia[0]);</span></span><br><span class="line">ia2 = <span class="number">42</span>;<span class="comment">//错误，ia2是一个指针</span></span><br><span class="line"><span class="keyword">decltype</span>(ia) ia3 = &#123;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;<span class="comment">//返回的是由10个整数构成的数组</span></span><br></pre></td></tr></table></figure><p><strong>数组也是迭代器</strong></p><p>迭代器支持的运算，数组的指针均支持，若想像迭代器一般遍历整个数组可以先获取指向数组的第一元素和指向数组最后一个元素的下一位的指针。</p><p>数组的首元素可通过直接数组名字即可得到，而尾后元素需要设法获取。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> *begin = arr; begin != arr[<span class="number">10</span>]; ++begin)</span><br><span class="line">cout &lt;&lt; *begin &lt;&lt;endl;</span><br></pre></td></tr></table></figure><p><strong>标准库函数begin和end</strong></p><p>C++引入了begin和end函数以得到数组首元素和尾后元素,由于内置数字不是类类型，所以两个函数不是成员函数，正确的做法是将数组作为参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">10</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="type">int</span> *pbegin = <span class="built_in">begin</span>(arr);</span><br><span class="line"><span class="type">int</span> *pend = <span class="built_in">end</span>(arr);</span><br></pre></td></tr></table></figure><p><strong>指针运算</strong></p><p>解引用</p><p>递增</p><p>递减</p><p>比较</p><p>与整数相加</p><p>两个指针相减：结果为<strong>ptrdiff_t</strong>的标准库类型，也是定义在cstddef头文件当中，其是一种带符号的类型</p><h2 id="C标准库String函数"><a href="#C标准库String函数" class="headerlink" title="C标准库String函数"></a>C标准库String函数</h2><p>该标准库定义于cstring头文件当中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">strlen</span>(p);</span><br><span class="line"><span class="built_in">strcmp</span>(p1,p2);</span><br><span class="line"><span class="built_in">strcat</span>(p1,p2);</span><br><span class="line"><span class="built_in">strcpy</span>(p1,p2);</span><br></pre></td></tr></table></figure><h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p><strong>C++没有严格的多维数组，只有数组的数组</strong></p><p>当一个数组的元素仍为数组时，通常使用两个维度来定义它：一个维度表示数组本身的大小，另外一个维度表示其元素（也是数组）的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];<span class="comment">//大小为3的数组，每个数组含有4个整数的数组</span></span><br></pre></td></tr></table></figure><p><strong>多维数组的初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用花括号括起来一组初始化多维数组</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]=&#123;<span class="comment">//数组有三个元素，每个元素都是大小为4的数组</span></span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">    &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有用花括号,与上面等价</span></span><br><span class="line"><span class="type">int</span> ia2[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可只初始化某一行某个元素</span></span><br><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>]=&#123; &#123;<span class="number">0</span>&#125;, &#123;<span class="number">7</span>&#125;,&#123;<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//只初始化某行</span></span><br><span class="line"><span class="type">int</span> ix[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>多维数组的下标引用</strong></p><p>可以使用下标运算来访问多维数组的元素，此时数组的每个维度对应一个下标运算符。</p><p>若表达式含有的下标运算符数量和数组的维度一样多：该表达式的结果将是给定类型的元素；</p><p><em><strong>若表达式含有的下标运算符数量比数组的维度小，则表达式的结果将是给定索引处的一个内层数组。</strong></em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line">ia[<span class="number">2</span>][<span class="number">3</span>] = arr[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>];<span class="comment">//arr的首元素为最后一行的最后一个一个元素赋值</span></span><br><span class="line"><span class="built_in">int</span> (&amp;row)[<span class="number">4</span>] = ia[<span class="number">1</span>];<span class="comment">//将row绑定到ia的第二个4元素数组上</span></span><br></pre></td></tr></table></figure><p>在第一个例子中，对于用于的两个数组来说，表达式提供的下标运算符数量都和它们各自的维度相同</p><p>在等号左边（右边类似）：ia[2]得到数组ia的最后一行，返回是是表示ia的最后一行的那个一维数组而非实际元素。</p><p>对于这个一维数组再取下标，得到编号为3的元素，就是这一行的最后一个元素。</p><p>在第二例当中，row定义为含有4个整数的数组的引用，然后将其绑定到ia的第二行</p><p><strong>指针和多维数组</strong></p><p>当程序使用多维数组的名字时，也会自动将其转换指向数组首元素的指针。</p><p>因为多维数组实际上时数组的数组，所以由多维数组名转换得来的指针实际上是指向第一个内层数组的指针：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="built_in">int</span> (*p)[<span class="number">4</span>] = ia;<span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line">p = &amp;ia[<span class="number">2</span>];<span class="comment">//p指向ia的尾元素</span></span><br></pre></td></tr></table></figure><p>随着C++11标准的提出，通过使用auto或者decltype就尽可能避免在数组前面加上一个指针类型了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//p指向含有4个整数的数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = ia; p! ia+<span class="number">3</span>; ++p)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//q指向4个整数数组的首元素，即q指向一个整数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q = *p; q != *p+<span class="number">4</span>;++q)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; *q &lt;&lt;<span class="string">&#x27;&#x27;;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    cout &lt;&lt; endl;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h1&gt;&lt;h2 id=&quot;命名空间的using声明&quot;&gt;&lt;a href=&quot;#命名空间的using声明&quot; class=&quot;headerlink&quot; title=&quot;命名空间的usin</summary>
      
    
    
    
    <category term="C++" scheme="https://dnanye.gitee.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://dnanye.gitee.io/tags/C/"/>
    
    <category term="容器" scheme="https://dnanye.gitee.io/tags/%E5%AE%B9%E5%99%A8/"/>
    
    <category term="字符串" scheme="https://dnanye.gitee.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    
    <category term="数组" scheme="https://dnanye.gitee.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>c++语句与表达式</title>
    <link href="https://dnanye.gitee.io/2022/09/12/c-%E5%9F%BA%E7%A1%80/c-%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://dnanye.gitee.io/2022/09/12/c-%E5%9F%BA%E7%A1%80/c-%E8%AF%AD%E5%8F%A5%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-09-12T11:17:56.000Z</published>
    <updated>2022-09-12T11:22:45.143Z</updated>
    
    <content type="html"><![CDATA[<h1 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h1><p>表达式是由一个或多个运算对象组成，对表达式求值将得到一个结果。</p><p>字面值和变量是最简单的表达式，其结果就是字面值和变量的值。</p><p><strong>基本概念</strong></p><ol><li><p>一元运算符（例如&amp; 、<em>）和二元运算符（+、-、</em>、&#x2F;），三元运算符（ ? : )</p></li><li><p>组合运算符和运算对象</p></li><li><p>运算符对象转换</p></li><li><p>重载运算符</p></li><li><p>左值和右值（C++语句要么是右值、要么是左值）</p><ol><li><p>一个左值表达式的求值结果是一个对象或者一个函数。</p><p><strong>常量对象为代表的某些左值实际上不能作为赋值语句的左侧运算对象</strong></p><p>虽然某些表达式的求值结果是对象，但是它是右值。</p><p>​<strong>总结：</strong></p><p>​<strong>当一个对象用作右值的时候，用的是对象的内容</strong></p><p>​<strong>当一个对象用作左值的时候，用的是对象的身份（在内存当中的位置）</strong></p><p>在需要右值的时候可以用左值来代替，但是不能将右值当中左值（位置）使用</p><p>当一个左值被当中右值使用时，实际使用的是它的内容。</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">0</span>；</span><br><span class="line">    i = i+<span class="number">1</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">i是一个对象，这个对象在赋值语句右侧时，用的是这个对象的值,该对象有一种右值属性</span></span><br><span class="line"><span class="comment">当对象在赋值语句的左侧时，用到是对象在内存中的地址，该对象具有左值属性</span></span><br><span class="line"><span class="comment">可以看到i是一个左值，但是它有着左值和右值属性</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li><li><p>优先级和结合律</p></li><li><p>求值顺序</p></li></ol><p><strong>算术运算符（+、-、*、&#x2F;、%）</strong></p><p><strong>逻辑和关系运算符</strong></p><p>！、&lt;、&gt;、&lt;&#x3D;、&#x3D;&gt;、&#x3D;&#x3D;、！&#x3D;、&amp;&amp;、||</p><p><strong>赋值运算符（&#x3D;）</strong></p><p><strong>递增、递减运算符（++、–)</strong></p><p><strong>成员访问运算符(-&gt;、.)</strong></p><p>点运输符和箭头运算符都可以用于访问对象</p><p><em><strong>点运算符用于获取类对象的一个成员</strong></em></p><p><em><strong>箭头运算符与点运算符有关</strong></em>，表达式：<code>ptr-&gt;mem和(*ptr).mem等价</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string s1 = <span class="string">&quot;a string&quot;</span>, *p = &amp;s1;</span><br><span class="line"><span class="keyword">auto</span> n = s1.<span class="built_in">size</span>();</span><br><span class="line"> n = (*p).<span class="built_in">size</span>();</span><br><span class="line"> n = p-&gt;<span class="built_in">size</span>()</span><br></pre></td></tr></table></figure><p><strong>条件运算符（ ?  : )</strong></p><p><strong>位运算符（~、&lt;&lt;、&gt;&gt;、&amp;、^、|)</strong></p><p><strong>sizeof运算符</strong></p><p>sizeof运算符返回一条表达式或一个类型名字所占的字节数。</p><p>szieof满足右结合律，得到一个size_t类型的常量表达式，运算形式如下：</p><p><strong>sizeof(type)</strong></p><p><strong>sizeof expr</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Sales_data data, *p;</span><br><span class="line"><span class="built_in">sizeof</span> (Sales_data);<span class="comment">//存储Sales_data类型的对象所占空间大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data;<span class="comment">//data类型的大小，即Sales_data类型所占空间大小</span></span><br><span class="line"><span class="built_in">sizeof</span> (p);<span class="comment">//指针所占的大小</span></span><br><span class="line"><span class="built_in">sizeof</span> (*p);<span class="comment">//p指向对象的大小，即Sales_data类型所占空间大小</span></span><br><span class="line"><span class="keyword">sizeof</span> data.revenue;<span class="comment">//对象成员的大小</span></span><br></pre></td></tr></table></figure><p>sizeof运算结果部分依赖与其作用的类型：</p><ol><li>char表达式或char类型执行sizeof运算，结果为1</li><li>对引用类型执行sizeof得到被引用对象所占空间的大小</li><li>对指针执行sizeof得到指针本身大小</li><li>对解引用指针执行sizeof得到指向对象的空间大小</li><li>对数组执行sizeof得到整个数组所占空间的大小</li><li>对string&#x2F;vector类型对象执行sizeof运算符只返回该固定部分的大小</li></ol><p><strong>逗号运算符</strong></p><p><strong>类型转换</strong></p><p>隐式转换：略</p><p>显式转换：</p><p>当我们需要显式的将对象转换成另外一种类型，叫做<strong>强制类型转换（cast)</strong></p><p>一个命名的强制类型转换具有如下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*******</span></span><br><span class="line"><span class="comment">type是目标类型</span></span><br><span class="line"><span class="comment">expression是要转换的值</span></span><br><span class="line"><span class="comment">cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast当中的一种</span></span><br><span class="line"><span class="comment">*********/</span></span><br><span class="line">cast-<span class="built_in">name</span>&lt;name&gt;()(expression)</span><br></pre></td></tr></table></figure><p> <strong>static_cast</strong></p><p>任何具有明确定义的类型转换，只要不包含底层const，都可以使用static_cast</p><p>当需要将一个较大的算术类型转换为较小的算术类型时，static_cast非常有效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="type">double</span> slope = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(j) ;</span><br></pre></td></tr></table></figure><p>static_cast对于无法自动执行的类型转换也非常有效。例如利用static_cast找到void*指针的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void *p = &amp;d;//任何非常量对象的地址均可存入void*</span><br><span class="line">double *dp = static_cast&lt;double*&gt;(p);</span><br></pre></td></tr></table></figure><p><strong>const_cast</strong></p><p>const_cast只能改变运算对象的底层const，将底层const转换为普通对象，也只有const_cast能够去除const属性,但是不能更改表达式类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span> *pc;</span><br><span class="line"><span class="type">char</span> *p = <span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(pc);<span class="comment">//通过p写值是未定义的行为</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> *q = <span class="keyword">static_cast</span>&lt;<span class="type">char</span>*&gt; （pc)<span class="comment">//错误，不能通过static_cast修改const属性</span></span><br></pre></td></tr></table></figure><p><strong>reinterpret_cast</strong></p><p>为运算对象的位模式提供较低层次的重新解释。</p><h1 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h1><p><strong>表达式语句</strong>：表达式加上分号;</p><p><strong>空语句</strong>：只有;</p><p><strong>复合语句</strong></p><p><strong>语句作用域</strong></p><p><strong>条件语句</strong></p><p><strong>迭代语句</strong></p><p><strong>跳转语句</strong></p><p><strong>语句处理语句</strong></p><h1 id="标准异常"><a href="#标准异常" class="headerlink" title="标准异常"></a>标准异常</h1><p>C++标准库 定义了一组类用于报告标准库函数遇到的问题，分别定义在以下4个头文件当中：</p><ol><li>exception:最通常的异常类</li><li>stdexcept</li><li>new：定义了bad_alloc异常</li><li>type_info：定义了bad_cast异常</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;表达式&quot;&gt;&lt;a href=&quot;#表达式&quot; class=&quot;headerlink&quot; title=&quot;表达式&quot;&gt;&lt;/a&gt;表达式&lt;/h1&gt;&lt;p&gt;表达式是由一个或多个运算对象组成，对表达式求值将得到一个结果。&lt;/p&gt;
&lt;p&gt;字面值和变量是最简单的表达式，其结果就是字面值和变量的</summary>
      
    
    
    
    <category term="C++" scheme="https://dnanye.gitee.io/categories/C/"/>
    
    
    <category term="C++" scheme="https://dnanye.gitee.io/tags/C/"/>
    
    <category term="语句" scheme="https://dnanye.gitee.io/tags/%E8%AF%AD%E5%8F%A5/"/>
    
    <category term="表达式" scheme="https://dnanye.gitee.io/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
    <category term="类型转换" scheme="https://dnanye.gitee.io/tags/%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>C#当中的类和对象</title>
    <link href="https://dnanye.gitee.io/2022/09/10/c-class/"/>
    <id>https://dnanye.gitee.io/2022/09/10/c-class/</id>
    <published>2022-09-10T09:43:36.000Z</published>
    <updated>2022-09-10T09:49:24.663Z</updated>
    
    <content type="html"><![CDATA[<p>在C#需要使用对象进行编程实现时，我们需要将该对象的类给定义出来，毕竟类定义了每个对象应该有的什么属性（这里的属性和下文的属性不一样，这里的属性是指实体对象应当具有的特性）和什么动作。</p><p>创建新类的语法如下：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[访问修饰符] <span class="keyword">class</span> 类名</span><br><span class="line">&#123;</span><br><span class="line">    [访问修饰符] &lt;数据类型&gt; 数据成员；<span class="comment">//字段，这里和java的名称不一样在java当中称为属性</span></span><br><span class="line">    [访问修饰符] &lt;返回值类型&gt; 方法名；    <span class="comment">//成员函数</span></span><br><span class="line">     <span class="comment">/*...</span></span><br><span class="line"><span class="comment">     除了定义以上两种成员意外我们还可以定义</span></span><br><span class="line"><span class="comment">     事件</span></span><br><span class="line"><span class="comment">     嵌套类</span></span><br><span class="line"><span class="comment">     属性（这个和java的不一样啊！！！）</span></span><br><span class="line"><span class="comment">     构造函数（很重要）</span></span><br><span class="line"><span class="comment">     析构函数</span></span><br><span class="line"><span class="comment">     ....</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问修饰符指定了类和其成员的访问权限规则，不指定则使用默认权限,修饰符有以下几种</p><p><em><strong>public</strong></em>: 公有访问，可以被是由任意程序集访问</p><p><em><strong>private</strong></em>: 私有访问，仅限本类成员（数据成员与方法成员访问）</p><p><em><strong>internal</strong></em>：内部访问，在该程序集里的所有类均可访问</p><p><em><strong>protected</strong></em>: 受保护访问，仅能由本类与该类的派生类访问。</p><p>下面我们做一下举例：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span><span class="title">People</span><span class="comment">//创建“人”这个类</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">string</span>name;<span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">public</span> <span class="built_in">int</span> age;<span class="comment">//年龄</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span> sex;<span class="comment">//性别</span></span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">int</span>ID;<span class="comment">//ID号码</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span>()</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//方法体（略）</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span><span class="title">Dog</span><span class="comment">//默认的访问修饰符为internal</span></span><br><span class="line">        &#123;</span><br><span class="line">         <span class="keyword">public</span> <span class="built_in">string</span> name;</span><br><span class="line">            <span class="keyword">public</span> <span class="built_in">int</span> age;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> run</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">internal</span> Date<span class="comment">//是不是觉得很怪，但是它是表示protected or internal</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到<em><strong>class</strong></em>的定义你是否会想到<em><strong>C</strong></em>语言里面的结构体，想道它是否可以像<em><strong>C++<em><strong>那样用于定义类呢？其实</strong></em>class</strong></em>和<em><strong>struct</strong></em>可以用于创建对象，只不过<em><strong>struct</strong></em>创建的对象分布在<strong>栈</strong>上，<em><strong>class</strong></em>创建的对象则托管在<strong>堆</strong>上面。</p><p>好了，我们已经知道了如何定义一个模板，那么我们如何根据模板创建一个实例呢？就像我们到餐厅点餐一样，我们知道了菜单。</p><p>如何将菜单上的菜转换为一道可以食用的菜呢？不可能将菜单当作实物吃了吧！这时就想要让服务员告诉后厨我们需要的菜，并且后厨开始准备我们的菜，然后菜做好后让服务员从后厨端上来！</p><p>这个过程就是<strong>实例化对象</strong>的过程，我们现在不对这个过程进行讲解，只要告诉你一个实例化对象的方法：使用<em><strong>new</strong></em>运算符就可实现。<del>所以编程圈里面有个笑话，找不到对象怎么办，new一个对象出来就行了</del></p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date date=<span class="keyword">new</span> Date();</span><br></pre></td></tr></table></figure><p>date是Date对象的名字，它到底存储的是什么我没找到答案，如果按照之前说的它是JAVA、C++等语言的集合体，那么我们可以推断其保存的是指向该对象的指针或引用。</p><p>实例化对象的实质是在内存当中开辟一块内存（如果使用的是<em><strong>class</strong></em>,在堆内存存储，如果使用的是<em><strong>struct</strong></em>则在栈内存储）存储对象的字段和方法，而<strong>类则不会开辟内存，只有将类实例化为对象才会开辟对象。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在C#需要使用对象进行编程实现时，我们需要将该对象的类给定义出来，毕竟类定义了每个对象应该有的什么属性（这里的属性和下文的属性不一样，这里的属性是指实体对象应当具有的特性）和什么动作。&lt;/p&gt;
&lt;p&gt;创建新类的语法如下：&lt;/p&gt;
&lt;figure class=&quot;highlig</summary>
      
    
    
    
    <category term="C#" scheme="https://dnanye.gitee.io/categories/C/"/>
    
    
    <category term="C#" scheme="https://dnanye.gitee.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://dnanye.gitee.io/2022/09/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://dnanye.gitee.io/2022/09/10/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2022-09-10T04:46:05.000Z</published>
    <updated>2022-09-12T07:28:29.119Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-面向对象编程"><a href="#C-面向对象编程" class="headerlink" title="C#面向对象编程"></a>C#面向对象编程</h1><p>我们之前提到很多次的面向对象，那么你应该有一个疑惑：对象，这是个嘛玩意？可以用来做什么？</p><p>在说面向对象之前，我们先看一段对话：</p><blockquote><p>苏格拉底:我们的论敌要问了:请告诉我什么是美?</p><p>希庇亚:我想他问的问题是,什么东西是美的? </p><p>苏格拉底:我想不是这个意思,他要问的是美是什么。</p><p>希庇亚:这两个问题有区别吗?</p><p>苏格拉底:有区别。他问的不是:什么东西是美的,而是:什么是 美?请你想一想。</p><p>希庇亚:我懂了,我来告诉他什么是美,叫他无法反驳。什么是美， 苏格拉底你记清楚,美是一位漂亮小姐。</p><p>苏格拉底:好!回答得真妙!不过我要是这样回答,可要遭到论敌反驳。我的论敌会这样问我:“苏格拉底,请答复这个问题:凡是美的那些东西真正是美,是不是因为有一个美本身存在,才使那些东西美 ?”我就会回答他说,一位漂亮的年轻小姐的美,就是使一切东西成其为美的。你以为如何?</p><p>希庇亚: 他敢说漂亮的年轻小姐不美吗?</p><p>苏格拉底:他当然敢,他会说:“你真妙,苏格拉底,但是一匹漂亮的母马不也可以是美的吗?神不是也曾经称赞过马的美?”</p><p>希庇亚:不错,神说母马很美,是有道理的。</p></blockquote><p>看出来了吗？苏格拉底一说的“美”是一种抽象的概念，而希庇亚则用具体的事物进行回答。</p><p>按照上面的逻辑我们可以得知一个推论：</p><p>“美”这个概念是一切美的事物所具有的抽象集合体，而“美人”、“马”这些东西则是具有“美”这个共有概念的具体实物。</p><p>那么我们也可以继续推导到我们需要的概念：某个抽象的概念是一群具有共有的特性的实物而形成的，而每个实物都具有该概念的特性。可能有点过于抽象了，我们这样说：</p><p>狗是一个抽象的概念吧，每种狗都有一些特有的属性（例如具有身高、体重）和一些动作（跑、跳、走）。</p><p>比如某一只哈士奇是一个具体的动物吧，它具有狗这个抽象概念这一特性的所有内容，它包含狗所特有的属性和动作。例如这只狗身高一米，体重40斤，它也会跑、会走。</p><p>那么我们就可以说“狗”这一对所有狗具有的所有特性的抽象概念叫做<strong>类</strong>，类就是一个<strong>模板</strong>，它并不是一个具体的东西，例如我们我们根据“狗”这抽象概念，我们以后发现一种新的生物它满足这个概念的全部内容，那么我们会将其称为某一种狗。那种生物就是狗这个抽象概念的具体实现。</p><p>按照我们前面说的那种生物的某一只实体（你随便可以将它命名为Al狗，只要是一种狗就行了）是根据“狗”这一抽象概念的具体实现我们叫做<strong>对象</strong>，既然如此某只哈士奇也是“狗”这一抽象概念的具体实现”，我们也叫哈士奇是一个对象。</p><p>好了！我们总结一下<strong>：类就是所有对象的抽象，所有对象就是类的具体实现，对象具有类这个模板的所有特性！！！</strong></p><p>既然我们知道了什么是对象了，那么面向对象又是什么呢？这一点我们和面向过程编程对比举个栗子说一下：</p><p>比如笔者看书这个行为，如果用面向过程编程的方式要这么做：笔者去寻找笔者需要看的书，笔者看到需要的书后将其拿到书桌，笔者翻开书，书被翻开，笔者好好的看书，最后将书闭合放回原处。</p><p>如果用面向对象编程的方式只要这么做：定义两个对象，一个对象是由三次元的“人”这个类具体化而成的“笔者”这个对象，笔者这个对象需要定义几个属性：姓名、性别、地址、编号——不然这怎么确认我是我呢！（笑）还要几个动作（找书、拿书、翻书、放书）才能完成看书这个事件。</p><p>一个对象是书，也需要定义几个属性：书名、ISBN编号、作者等等相关信息，不然笔者可能找到一堆莫名其妙的东西了！还有一个书被翻开的动作。</p><p>面向对象只需要将两个对象组合在一起就可以完成这一个程序的所有功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-面向对象编程&quot;&gt;&lt;a href=&quot;#C-面向对象编程&quot; class=&quot;headerlink&quot; title=&quot;C#面向对象编程&quot;&gt;&lt;/a&gt;C#面向对象编程&lt;/h1&gt;&lt;p&gt;我们之前提到很多次的面向对象，那么你应该有一个疑惑：对象，这是个嘛玩意？可以用来做什么？&lt;/</summary>
      
    
    
    
    <category term="C#" scheme="https://dnanye.gitee.io/categories/C/"/>
    
    
    <category term="JAVA" scheme="https://dnanye.gitee.io/tags/JAVA/"/>
    
    <category term="C++" scheme="https://dnanye.gitee.io/tags/C/"/>
    
    <category term="C#" scheme="https://dnanye.gitee.io/tags/C/"/>
    
    <category term="面向对象" scheme="https://dnanye.gitee.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>C#语法基础</title>
    <link href="https://dnanye.gitee.io/2022/09/10/C-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    <id>https://dnanye.gitee.io/2022/09/10/C-%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80/</id>
    <published>2022-09-10T01:56:23.000Z</published>
    <updated>2022-09-10T02:10:44.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="语法基础"><a href="#语法基础" class="headerlink" title="语法基础"></a>语法基础</h1><p>本部分重点指出<em><strong>C#<em><strong>不同于</strong></em>C</strong></em>语言之间不同的部分，相同部分会一句带过，如果有不明白的地方请看<em><strong>《C Primer Plus》</strong></em>，在此不再赘述了。</p><h2 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h2><p> C#的数据类型分为值类型与引用数据类型</p><h3 id="2-1-1-值类型"><a href="#2-1-1-值类型" class="headerlink" title="2.1.1 值类型"></a>2.1.1 值类型</h3><ol><li>整型</li></ol><table><thead><tr><th>数据类型</th><th>标识符</th><th>范围</th></tr></thead><tbody><tr><td>字节</td><td>sbyte</td><td>-128~127</td></tr><tr><td>无符号字节</td><td>byte</td><td>0~255</td></tr><tr><td>短整型</td><td>short</td><td>-32768~32767</td></tr><tr><td>无符号短整型</td><td>ushort</td><td>0~65535</td></tr><tr><td>整型</td><td>int</td><td>-2147483648~2147483647</td></tr><tr><td>无符号整型</td><td>uint</td><td>0~2147483647*2+1</td></tr><tr><td>长整形</td><td>long</td><td>-~+</td></tr><tr><td>无符号整型</td><td>ulong</td><td>0~+</td></tr></tbody></table><ol start="2"><li><p>浮点型</p><p>单精度float</p></li></ol><p>​双精度double</p><p>​       十进制实数decimal       字节数为16</p><pre><code>3. 字符型charASCII、Unicode编程字符、转义字符   4. 布尔型（bool)     true\false   5. 结构类型struct   6. 枚举类型enum</code></pre><h3 id="2-1-2-引用类型"><a href="#2-1-2-引用类型" class="headerlink" title="2.1.2 引用类型"></a>2.1.2 引用类型</h3><p>在引用类型当中，不会直接存储数值，而是存储实际数值的<strong>引用（地址）</strong></p><p>C#的引用类型分为数组、类、接口、委托、内置引用类型、字符串</p><p>​<strong>1. 数组</strong></p><p>作用：将一批类型相同的数据元素存储到一块连续的内存块中，每个元素对应有一个唯一的索引。</p><p>声明一维数组：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">baseType[] arrayName;<span class="comment">//baseType为数组类型，可以是值类型，也可以是引用类型</span></span><br><span class="line"><span class="comment">//例：</span></span><br><span class="line"><span class="built_in">int</span> [] array;<span class="comment">//为int类型数组</span></span><br><span class="line"><span class="built_in">string</span>[] s1;<span class="comment">//为string类型数组</span></span><br><span class="line">Animal [] animalArr;<span class="comment">//为类类型的数组</span></span><br></pre></td></tr></table></figure><p>定义一维数组（实例化数组）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int [] array=new int[5];</span><br><span class="line">int [] array1=&#123;1,2,3,4&#125;;</span><br></pre></td></tr></table></figure><p>获取数组长度</p><p>通过Array类的<em><strong>length</strong></em>属性即可得到</p><p>二维数组：每个数组元素均由n个该类型发数据构成。</p><p>定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baseType[,] array=new baseType[N1,N2];</span><br></pre></td></tr></table></figure><p>​    <strong>2. 字符串</strong></p><p>类型关键字为string,声明一个string类型数据，其实就是在内存空间创建了一个空的引用关系。</p><p>初始化一个字符串，相当于引用了多个字符类型的数据</p><h3 id="2-1-3-类型转换"><a href="#2-1-3-类型转换" class="headerlink" title="2.1.3 类型转换"></a>2.1.3 类型转换</h3><p><strong>1.隐式转换（编译器直接转换）</strong></p><p>值类型到值类型的一般转换（例如float–&gt;double等等)在此不多赘述，我们需要了解的是将值类型到引用类型的转换。</p><p>装箱就是自动将基本数据类型转换为引用类型，拆箱就是自动将引用类型转换为基本数据类型（在java当中非常有用的一个功能）</p><p>例如要将值类型转换为object类型，可以创建一个基于该值类型的object实例。</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span> chData=<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">object</span> obj=ch;</span><br><span class="line">Console.WriteLine(obj);<span class="comment">//输出a</span></span><br></pre></td></tr></table></figure><p><strong>2.显式转换（用户直接转换）</strong></p><p>值类型的：</p><p>（类型名）（表达式）</p><p>拆箱：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a=1;</span><br><span class="line">object obj=a;</span><br><span class="line">int intA=(int)obj;</span><br></pre></td></tr></table></figure><p>使用<em><strong>Convert</strong></em>命令显示转换，例如<em><strong>Convert.ToBoolean(value);</strong></em></p><h2 id="2-2-变量与常量-略"><a href="#2-2-变量与常量-略" class="headerlink" title="2.2 变量与常量(略)"></a>2.2 变量与常量(略)</h2><p>这个东西哪个语言都差不多，不想再说了-____-</p><h2 id="2-3-语句"><a href="#2-3-语句" class="headerlink" title="2.3 语句"></a>2.3 语句</h2><p>只列一下语句的类型</p><p><strong>1.表达式语句</strong>（算术、赋值、关系、逻辑、位等运算）</p><p><strong>2.流程控制语句</strong>（if\else、switch、while\do…while、for、foreach（用于遍历数组）、循环中断【break\continue\goto】)</p><p>这里重点提一下foreach语句：</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> [] arr=<span class="keyword">new</span> <span class="built_in">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">    arr[i]=i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">int</span> j=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">foreach</span>(<span class="built_in">int</span> i <span class="keyword">in</span> arr)<span class="comment">//i代替了arr当中的每个元素的变量名，它会自动遍历所有的元素，直到遍历完成</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">&quot;array[&#123;0&#125;]=&#123;1&#125;&quot;</span>,j++,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>3.异常处理语句</strong></p><p>在程序运行过程中，经常遇到错误而中断而中断程序的运行，这种情况叫做异常。</p><p>在.NET Framework中，异常的基类（后面在继承会说明这个概念）为Exception.</p><p>处理异常的语句有<em><strong>try…catch</strong></em>、<em><strong>throw</strong></em>、<em><strong>finally</strong></em>(这个语句和大多数面向对象编程语言一致)</p><p>throw语句在特点情况下自动抛出异常，基本格式为</p><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> expresion<span class="comment">//expresion表示抛出的异常类型的对象（派生至System.Exception类的对象）</span></span><br></pre></td></tr></table></figure><p>当 throw 语句执行时，它后面的语句将不执行，此时程序转向调用者程序，寻找与之相匹配的 catch 语句，执行相应的异常处理程序。如果没有找到相匹配的 catch 语句，则再转向上一层的调用程序。这样逐层向上，直到最外层的异常处理程序终止程序并打印出调用栈情况。</p><p><em><strong>try…catch</strong></em>有三种形式：<em><strong>try</strong></em>后面跟一个或多个<em><strong>catch</strong></em>块；一个<em><strong>try</strong></em>块后接一个<em><strong>finally块</strong></em>，<em><strong>try</strong></em>后面跟一个或多个<em><strong>catch</strong></em>块后接一个<em><strong>finally块</strong></em></p><h2 id="2-4-随机数"><a href="#2-4-随机数" class="headerlink" title="2.4 随机数"></a>2.4 随机数</h2><p>一般情况下我们使用都是<em><strong>伪随机数</strong></em>，它是由特定算法生成的随机数系列，并不是真正的随机数，但是有着随机数的一般性质。生成随机数需要给定随机种子，如果随机种子不变，生成的伪随机的数序也不会改变。在计算机当中往往采用伪随机数代替真正的随机数。</p><p>1、生成随机整数：</p><p>使用<em><strong>Rondom</strong></em>类创建对象，调用.Next()重载方法（方法的重载后面会讲，这里只需要知道重载就是方法的名字一样，参数类型或数目不一样）时，可以产生一个指定范围的随机整数。可以分为以下几种重载情况：</p><p><em><strong>.Next()</strong></em>:系统以当前时间为随机数种子，返回一个非负随机整数</p><p><em><strong>.Next(int maxValue)</strong></em>:系统以当前时间为随机数种子,返回一个0-~maxValue-1的随机整数</p><p><em><strong>.Next(int minValue,int maxValue)</strong></em>:系统以当前时间为随机数种子,返回一个minValue~maxValue的随机整数。</p><p>而当Random.NextDouble()接受double数据后，会与上述的方法差不多，只是返回值与形参变为了double了罢。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;语法基础&quot;&gt;&lt;a href=&quot;#语法基础&quot; class=&quot;headerlink&quot; title=&quot;语法基础&quot;&gt;&lt;/a&gt;语法基础&lt;/h1&gt;&lt;p&gt;本部分重点指出&lt;em&gt;&lt;strong&gt;C#&lt;em&gt;&lt;strong&gt;不同于&lt;/strong&gt;&lt;/em&gt;C&lt;/strong&gt;&lt;/</summary>
      
    
    
    
    <category term="C#" scheme="https://dnanye.gitee.io/categories/C/"/>
    
    
    <category term="C#" scheme="https://dnanye.gitee.io/tags/C/"/>
    
    <category term=".NET FrameWork" scheme="https://dnanye.gitee.io/tags/NET-FrameWork/"/>
    
  </entry>
  
  <entry>
    <title>c#概述</title>
    <link href="https://dnanye.gitee.io/2022/09/10/C-%E6%A6%82%E8%BF%B0/"/>
    <id>https://dnanye.gitee.io/2022/09/10/C-%E6%A6%82%E8%BF%B0/</id>
    <published>2022-09-10T01:44:22.000Z</published>
    <updated>2022-09-10T04:58:00.315Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一、C-概述"><a href="#一、C-概述" class="headerlink" title="一、C#概述"></a>一、C#概述</h1><h2 id="1-1-Mircosoft-NET平台概述"><a href="#1-1-Mircosoft-NET平台概述" class="headerlink" title="1.1 Mircosoft .NET平台概述"></a>1.1 Mircosoft .NET平台概述</h2><p><em><strong>.NET</strong></em>平台是微软开发的软件开发平台，是一种用于<em>Windows</em>操作系统的托管代码编程模型。</p><p><em><strong>.NET</strong></em>平台和<em><strong>JAVA</strong></em>一样提供了大量类库供开发者使用，其中就包括了我们正在学习的C#语言</p><p><em><strong>.NET</strong></em>框架有着以下特点：</p><ol><li>具有统一的应用层接口</li><li>基于面向对象的开发</li><li>能够支持多种开发语言</li></ol><h2 id="1-2-C-语言简介"><a href="#1-2-C-语言简介" class="headerlink" title="1.2 C#语言简介"></a>1.2 C#语言简介</h2><p><em><em>C#<strong>是微软基于</strong></em>.NET</em>**框架、面向对象的高级语言，是由JAVA、C、C++派生而来的。</p><p>C#语言的基本思想就是<strong>面向对象(OOP)</strong>,面向对象就是将数据的操作都封装到一个称为<strong>类</strong>的数据结构当中。</p><p><strong>OOP</strong>的三大特性为<strong>封装、继承和多态</strong></p><p>C#技术体系有以下：</p><ol><li>全面面向对象设计</li><li>Windows Form技术</li><li>WPF技术</li><li>WebForm技术</li><li>MVC技术</li></ol><p>C#特点：</p><ol><li>指针限制（学习过C++的同学应该深有体会）</li><li>垃圾回收机制(GC)</li><li>支持泛型编程（目前这个大多数面向对象语言已经实现）</li><li>单继承机制（不同于C++的多继承机制）</li><li>C#更加强调类型安全</li></ol><p>C#类库的基本分类：</p><ol><li>数据访问类</li><li>窗体类</li><li>安全类</li><li>XML类</li><li>线程类</li><li>输入&#x2F;输出类</li><li>Web类</li></ol><h2 id="1-3-集成开发环境"><a href="#1-3-集成开发环境" class="headerlink" title="1.3 集成开发环境"></a>1.3 集成开发环境</h2><p><em><strong>Visual Studio 2019</strong></em> </p><p>笔者曾在Linux系统下配置相关环境，但是很多功能无法完整实现，所以没有办法向Java那样一处编译，到处运行(<del>一处编译，到处报错</del>)了!!!</p><p><strong>文件后缀名问题</strong></p><p>解决方案<strong>.sln</strong></p><p>项目后缀名<strong>.csproj</strong></p><p>源代码<strong>.cs</strong></p><h2 id="1-4-C-程序结构介绍"><a href="#1-4-C-程序结构介绍" class="headerlink" title="1.4 C#程序结构介绍"></a>1.4 C#程序结构介绍</h2><figure class="highlight c#"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> System;<span class="comment">//导入命名空间，和java当中的import关键字一样，而namespace则与java当中的package类似</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="title">Demo1</span><span class="comment">//命名空间定义，以namespace关键字与一对大括号组成</span></span><br><span class="line">    <span class="comment">//作用是文件系统当中的目录一般。当你的程序规模非常大后，可能你的方法名和其他类的方法名会重名</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title">Program</span><span class="comment">//完整类名为Demo.Program(C++的表示为Demo::Program,java则与之类似)</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)<span class="comment">//与JAVA的类似(public static void main(String[] args))</span></span></span><br><span class="line">        &#123;   <span class="comment">//Main()是整个程序的入口，string[] args可接受命令行参数</span></span><br><span class="line">            </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;Hello World!!!&quot;</span>)<span class="comment">//与Write方法一样用于标准输出设备，</span></span><br><span class="line">                <span class="comment">//而加了Line在输出时会自动加上一个换行</span></span><br><span class="line">                </span><br><span class="line">            Console.WriteLine(<span class="string">&quot;a=&#123;0&#125;,b=&#123;1&#125;&quot;</span>,<span class="string">&quot;hello&quot;</span>,<span class="string">&quot;world&quot;</span>);<span class="comment">//格式化输出，与C语言差不多</span></span><br><span class="line">            </span><br><span class="line">            Console.ReadLine();<span class="comment">//从标准输入一行字符（回车结束），返回一个字符串string</span></span><br><span class="line">            <span class="comment">//read读取一个int,如果为字符则int数据为该字符的ASCII码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一、C-概述&quot;&gt;&lt;a href=&quot;#一、C-概述&quot; class=&quot;headerlink&quot; title=&quot;一、C#概述&quot;&gt;&lt;/a&gt;一、C#概述&lt;/h1&gt;&lt;h2 id=&quot;1-1-Mircosoft-NET平台概述&quot;&gt;&lt;a href=&quot;#1-1-Mircosoft-NE</summary>
      
    
    
    
    <category term="C#" scheme="https://dnanye.gitee.io/categories/C/"/>
    
    
    <category term="C#" scheme="https://dnanye.gitee.io/tags/C/"/>
    
    <category term=".NET FrameWork" scheme="https://dnanye.gitee.io/tags/NET-FrameWork/"/>
    
  </entry>
  
</feed>
